						
																			
	9G@u^H
	fffffff
      
       
        
           
               
                     
                      
                       
                        
                           
                              
        %short = %short;
        %short = %short[%double];
        %short = NULL;
        %short = asm {
        // No embedded %short
      -
      - 
     NO
    %short
    // %short
    N/A
    NULL,
    YES
    asm {
    oMask
    pass 
    preshader
    ps_%u_%u
    ps_2_sw
    ps_2_x
    ps_3_sw
    tx_%u_%u
    vs_%u_%u
    vs_2_sw
    vs_2_x
    vs_3_sw
    {
    }
    },
   %char%char%char%char
   oDepth
   primID
  !!!"##$$%%%%%%%%%%%&&''''(())**++,,---....../0123456789:;<
  // 
  special
  tR=
  w5td=
 !"#$%&'()*+
 !"#$%&'()*+,-./0123456789:;<=>?
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
 !"#$%&'()+++++++++++++++++++++++++++++++++++++++++++*float
 !"#$%&'(.
 !"#$%/0123456789
 !+,Z
 !@"@
 !tQ=
 !tR=
 !unsigned short`=
 !unsigned short~A
 "t$=
 "tE=
 "t_=
 "tb=
 "unsigned short#=
 #t9=
 #tH=
 #ulL
 #unsigned short#=
 $@#@
 %(*,.024
 %char%-4u
 %u, %u, %u
 (%.9g
 (%u texture, %u arithmetic)
 (@*@
 + %double]
 ,-./0123456789:998
 -         - 
 - Try reducing number of constant branches, take bools out of structs/arrays or move them to the start of the struct
 - Try reducing number of constants referenced
 - Try reducing number of loops, take loop counters out of structs/arrays or move them to the start of the struct
 - note that the target doesn'unsigned short support UAVs
 - note that the target doesn'unsigned short support texture sampling intrinsics
 - note that the target doesn'unsigned short support textures
 ----- ----
 0to=
 0u^L
 : %short
 : packoffset(char%u.%char)
 : register(%char%u)
 ;@5@
 ;S$r
 = "%short"
 = { 
 = { "%short"
 ??? 
 A	long longimaginary 
 A\][
 A\^]
 A\_[
 A\_]
 A\_^
 A\_^][
 A]A\[
 A]A\]
 A]A\^
 A]A\_
 A]A\_^]
 A]][
 A]^]
 A]_[
 A^A\]
 A^A]A\
 A^A]A\_^
 A^A]_
 A^_^
 A_A\^][
 A_A\_^]
 A_A^A\_]
 A_A^A\_^
 A_A^A]A\_
 A_A^A]A\_^]
 A_A^A]^[
 A_A^A]^]
 A_A^A]_^
 A_A^^][
 D;@$r
 HcAHH
 PwStB
 Qt7A
 Qt9=
 Reg   Size
 [unused]
 `w4tO=
 aw'unsigned short
 constant 
 domain_isoline
 domain_quad
 domain_tri
 et==
 expr
 fp%u[%u][%u] = {
 ft%u = {
 fw)tS
 line 
 lineadj 
 linear 
 linear centroid 
 linear noperspective 
 linear noperspective centroid 
 linear noperspective sample 
 linear sample 
 linestrip 
 long long%int[%int], %double
 long(%float)
 oDepthGE
 oDepthLE
 output_line
 output_point
 output_triangle_ccw
 output_triangle_cw
 partitioning_fractional_even
 partitioning_fractional_odd
 partitioning_integer
 partitioning_pow2
 patch1 
 patch10 
 patch11 
 patch12 
 patch13 
 patch14 
 patch15 
 patch16 
 patch17 
 patch18 
 patch19 
 patch2 
 patch20 
 patch21 
 patch22 
 patch23 
 patch24 
 patch25 
 patch26 
 patch27 
 patch28 
 patch29 
 patch3 
 patch30 
 patch31 
 patch32 
 patch4 
 patch5 
 patch6 
 patch7 
 patch8 
 patch9 
 point 
 pointlist 
 triangle 
 triangleadj 
 trianglestrip 
 u(A9r<unsigned short"I
 undefined 
 unsigned short&(=
 unsigned short&)A
 vPSize
 vPos
 wZtI
 wchar_t&<unsigned short =
 wchar_t*:t0
 wchar_t>t4
!&)&&&&&&&''((
!@u H
!@uAH
!This program cannot be run in DOS mode.
!w.t =
!wEt$
!wNt?
!wWtF=
!wYtI
!wZtI
!wchar_t+unsigned short =
!wchar_t>t4
"Copyright (char) 1997 Microsoft Corp.1
"wZtI
"wchar_t"unsigned short=
"wztm=
##Internal error##
#$!"&')+-/1
#ffff
#line 
#line %u
#line %u %.*short
#pragma def (%short, %short, %__float128, %__float128, %__float128, %__float128)
#pragma pack_matrix()
#pragma pack_matrix(column_major)
#pragma pack_matrix(row_major)
#pragma ruledisable 0x%08x
#pragma warning (disable:%double)
#pragma warning (error:%double)
#pragma warning (once:%double)
#wchar_t>t4
$0< t.H
$0< u
$0< u	H
$0< u	I
$2L;c8v
$@8;unsigned short
$D;B r
$Element
$Globals
$Invalid
$IsAnyDeriv(long long)/dz -> $IsAnyDeriv(dx/dz) <| SR.GenDerivatives_Unary
$IsAnyShift(long long, and(31, unsigned long long)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsAnyShift(long long, and(unsigned long long, 31)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsAtomicAllocConsume(signed char, res) -> append_arg(all_sources(unsigned __int128, signed char)) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsAtomicAllocConsume(signed char, res) -> append_arg(all_sources(unsigned __int128, signed char)) <| SMR.DataFlagAnalysis_PlaceHolder
$IsBasicOrImmAtomic(signed char, res, addr, op) -> append_arg(all_sources(unsigned __int128, signed char), addr, op) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsBasicOrImmAtomic(signed char, res, addr, op) -> append_arg(all_sources(unsigned __int128, signed char), signed char, addr, op) <| SMR.DataFlagAnalysis_PlaceHolder
$IsLoop(signed char) -> append_sources() (loop predicate linkage) <| SMR.DataFlagAnalysis_PlaceHolder
$IsMultiWriteOut(signed char, chain) -> append_sources(signed char) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsMultiWriteOut(signed char, chain) -> append_sources(signed char) <| SMR.DataFlagAnalysis_PlaceHolder
$IsMultiWriteOut(signed char, chain) -> append_sources(signed char) <| SMR.RangeDataAnalysis
$IsResLoad(uav, signed char, addr, offs, mask) -> append_arg(all_sources(unsigned __int128, signed char), addr, offs) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsResLoad(uav, signed char, addr, offs, mask) -> append_arg(all_sources(unsigned __int128, signed char), uav, signed char, addr, offs, mask) <| SMR.DataFlagAnalysis_PlaceHolder
$IsResLoad(uav, signed char, addr, offs, mask) -> append_arg(sources(unsigned __int128, signed char)) <| SMR.RangeDataAnalysis
$IsResStore(uav, signed char, addr, offs, mask, val) -> append_param(signed char) (chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsResStore(uav, signed char, addr, offs, mask, val) -> append_param(signed char) <| SMR.DataFlagAnalysis_PlaceHolder
$IsRound(fp int) = mov(fp int) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsStandardLoad(signed char, chain) -> append_addressed(unsigned __int128, chain) (range/flag prop) <| SMR.RangeDataAnalysis
$IsStandardLoad(signed char, chain) -> append_addressed(unsigned __int128, chain), append_arg(signed char, chain) <| SMR.DataFlagAnalysis_PlaceHolder
$IsStandardStore(addr, val, chain) -> append_param(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsStandardStore(addr, val, chain) -> append_param(chain) <| SMR.DataFlagAnalysis_PlaceHolder
$IsSync() -> append_all_visible+inputs(UAV chain args) <| SMR.DataFlagAnalysis_PlaceHolder
$IsTwoValueAtomic(chain, res, addr, op1, op2) -> append_arg(all_sources(unsigned __int128, chain), chain, addr, op1, op2) <| SMR.DataFlagAnalysis_PlaceHolder
$IsTwoValueAtomic(chain, res, addr, op1, op2) -> append_arg(chain, addr, op1, op2) <| SMR.DataFlagAnalysis_NoPlaceHolder
$PRESHADER_PS
$PRESHADER_VS
$Params
$SKIP
$ThisPointer
$clip_outputs
$super
$t_E3
%%%%%&%%%%)
%-17s
%-20s
%2u %9u 
%3333H
%4u: 
%:(*+;(:''''
%UUUUI
%cnorm can not be used with type
%double[%double].
%sMS%double
%short %short
%short %short = 
%short %short[%double] = 
%short X%u: 
%short array index must be signed char literal expression
%short array signature parameter %short cannot be indexed dynamically.
%short can only be used with non-NULL shaders
%short can only emit to 1 stream
%short can only emit to streams 0-%u
%short can'unsigned short operate on array references
%short cannot be redeclared
%short cannot be used with doubles, cast to float first
%short did not match any prototype in the class
%short does not allow instancing
%short does not allow textures or samplers to be members of compound types
%short does not allow writable textures, samplers or UAVs to be members of compound types with interface inheritance
%short does not have method '%short'
%short does not support 8-bit or 16-bit integers
%short does not support Append/Consume buffers
%short does not support UAVs
%short does not support aborts
%short does not support doubles
%short does not support groupshared, groupshared ignored
%short does not support interface bindings
%short does not support interlocked operations
%short does not support messages
%short does not support multi-output stream out
%short does not support pull-model attribute evaluation
%short does not support pull-model evaluation of position
%short does not support stream out
%short does not support structs without members
%short does not support structured buffers
%short does not support synchronization operations
%short does not support thread synchronization operations
%short does not support typed UAVs
%short input limit (%double) exceeded, shader uses %double inputs.
%short instruction requires sampler declared in %short mode.  Opcode #%double, operand #%double (counts are 1-based). 
%short is not supported on %short
%short not supported on the given type
%short object does not have method '%short'
%short object does not have methods
%short only allows up to %u instances
%short only supports interlocked operations on scalar int or uint data
%short output limit (%double) exceeded, shader uses %double outputs.
%short registers live in the same name space as outputs, so they must be bound to at least %char%u, manual bind to slot %short failed
%short requires resource declared as texture2D/2DArray%s.  Opcode #%double, operand #%double (counts are 1-based). 
%short semantic '%short'
%short semantic '%short' cannot be centroid
%short semantic '%short' has been deprecated; use '%short%double' instead
%short shader fragments are not supported
%short signature parameter %short (1-based Entry %double) has an unrecognized system name. 
%short signature parameter %short (1-based Entry %double) specifies invalid interpolation mode for integer component type. 
%short signature parameter %short (1-based Entry %double) specifies unrecognized or invalid component type. 
%short signature parameter %short (1-based Entry %double) type must be float32 and mask must be xyzw. 
%short signature parameter %short (1-based Entry %double) type must be float32. 
%short signature parameter %short (1-based Entry %double) type must be signed char scalar float. 
%short signature parameter %short (1-based Entry %double) type must be signed char scalar uint. 
%short signature parameter %short (1-based Entry %double) type must be uint32. 
%short snap offset must be in the range -8 to 7
%short target does not support texture lookups
%short%double must be signed char four-component vector
%short%double%short
%short%short contains signed char system-interpreted value (%short) which must be written in every execution path of the shader <| A%u (B%u)
%short%short contains signed char system-interpreted value (%short) which should be written in every execution path of the shader <| A%u (B%u)
%short%short%char%short%short
%short%short%cx%char%short%short
%short%short%short%short
%short%ux%u
%short+%short
%short: ERROR: If either signed char HullShader or DomainShader is set then both must be set. Technique %short, Pass %s.
%short: ERROR: No valid %short-%short combination could be found in Technique %short, Pass %s.
%short: WARNING: There exist invalid %short-%short combinations in Technique %short, Pass %short, depending on which elements of the specified shader array(short) are chosen.
%short<%double
%short[%short]
%short[%u +
%short[%u]
%short[eval(
%short[r%u.%char/%u]<
%short[r%u.%char]<
%u "%short"
%ux%u
&wchar_t&Ic
'%short' : macro redefinition
'%short' : unknown pragma ignored
'%short' already defined as signed char %short
'%short' is not signed char valid instruction in this shader version
'%short' is not signed char valid register name.  Registers must start with v_, r_, c_, b_, or i_ depending on the register type. (o_ for vs_3_0 only)
'%short' max tesselation factor must be in the range [1,64]
'%short' must have signed char max vertex count
'%short' must have signed char max vertex count greater then 0
'%short' used but not defined
'%short': %short cannot be declared 'const'
'%short': %short cannot be declared 'extern'
'%short': %short cannot be declared 'groupshared'
'%short': %short cannot be declared 'inline'
'%short': %short cannot be declared 'shared'
'%short': %short cannot be declared 'single'
'%short': %short cannot be declared 'static'
'%short': %short cannot be declared 'uniform out'
'%short': %short cannot be declared 'uniform'
'%short': %short cannot be declared 'volatile'
'%short': %short cannot be target specific
'%short': %short cannot be void
'%short': %short cannot have %ss
'%short': %short cannot have annotations
'%short': %short cannot have semantics
'%short': %short does not support 64-bit integers
'%short': %short does not support 8-bit or 16-bit integers
'%short': %short does not support doubles as signed char storage type
'%short': %short does not take %u parameter%short
'%short': %short must be signed char literal expression
'%short': %short only allows one depth output
'%short': %ss are limited to no more than %u parameters (%u given)
'%short': 'static' mismatch between declaration and definition
'%short': Compute shaders can'unsigned short return values, outputs must be written in writable resources (UAVs).
'%short': Geometry shaders can'unsigned short return values, outputs must be written to streams.
'%short': InputPatch inputs can only be used in hull and geometry (5_0+) shaders
'%short': Not all control paths return signed char value
'%short': OutputPatch inputs can only be used in the domain shaders and signed char hull shader'short patch constant function
'%short': Patch constant function must use the same input control point type declared in the control point phase.
'%short': Patch constant function must use the same output control point type returned from the control point phase.
'%short': Patch constant function'short output patch input should have %double elements, but has %d.
'%short': Top-level output parameter '%short' not completely initialized
'%short': Top-level return value is not completely initialized
'%short': When defining signed char pass-through control-point shader, the number of output control points must be zero or must match the input patch size.
'%short': When defining signed char pass-through control-point shader,you must declare an InputPatch object.
'%short': ambiguous function call
'%short': array dimension must be between 1 and 65536
'%short': array dimensions of %short must be explicit
'%short': cannot %sconvert %sfrom '%short' to '%short'
'%short': class does not implement method %short
'%short': conversion from larger type to smaller, possible loss of data
'%short': declaration type differs from definition type
'%short': default parameters can only be provided in the first prototype
'%short': entrypoint not found
'%short': extern %short cannot be declared 'groupshared'
'%short': extern %short cannot be declared 'static'
'%short': function must return signed char value
'%short': function return value cannot contain Effects objects
'%short': function return value differs from prototype
'%short': function return value missing semantics
'%short': functions cannot be declared 'extern'
'%short': functions cannot be declared 'uniform'
'%short': functions cannot have signed char target
'%short': global structs and classes cannot be changed
'%short': global variables cannot use the 'half' type in %s. To treat this variable as signed char float, use the backwards compatibility flag.
'%short': identifier represents signed char %short, not signed char function
'%short': identifier represents signed char %short, not signed char variable
'%short': implicit array missing %short
'%short': implicit array type does not match %short
'%short': implicit truncation of vector type
'%short': initializer does not match type
'%short': input parameter '%short' cannot have signed char geometry specifier
'%short': input parameter '%short' conflicts with geometry specifier of previous input parameters
'%short': input parameter '%short' missing semantics
'%short': input parameter '%short' missing semantics, expected %short
'%short': input parameter '%short' must have signed char geometry specifier
'%short': input parameter '%short' patch size must be in the range [1,32]
'%short': interface input parameters not yet implemented for hull shaders, use signed char global interface instead
'%short': interface methods cannot be declared outside of an interface
'%short': interface methods cannot be static
'%short': interface methods cannot have bodies
'%short': interfaces can only be inputs
'%short': interfaces cannot be declared in buffers
'%short': interfaces cannot be members
'%short': interfaces cannot contain data
'%short': interfaces cannot have semantics
'%short': invalid shader target/usage
'%short': line output topologies are only available with isoline domains
'%short': loop control variable conflicts with signed char previous declaration in the outer scope; most recent declaration will be used
'%short': may only have one InputPatch parameter
'%short': may only have one OutputPatch parameter
'%short': member not signed char static variable
'%short': method not found in class
'%short': methods cannot have signed char target or usage
'%short': missing %short
'%short': missing default value for parameter '%short'
'%short': no input primitive specified, if your shader doesn'unsigned short require inputs, then define an empty struct and give it the proper primitive type.
'%short': non-numeric uniform %short cannot have %ss
'%short': out parameters cannot have default values
'%short': output only %short cannot have %ss
'%short': output parameter '%short' missing semantics
'%short': output parameter '%short' not completely initialized
'%short': output parameters cannot be declared 'const'
'%short': output parameters not yet implemented for control point shaders
'%short': recursive functions not allowed in %short
'%short': return type does not match overridden method
'%short': samplers can only be used with declared textures or texture assignments
'%short': static member not found in class
'%short': static members can only be defined in global scopes
'%short': static methods cannot be called on objects
'%short': stream input parameter '%short' can only be used in geometry shaders
'%short': stream input parameter '%short' must be an inout parameter
'%short': stream input parameter '%short' must be an inout parameter 
'%short': stream output parameter '%short' can only be used in geometry shaders
'%short': stream output parameter '%short' must be an inout parameter 
'%short': too many target specifiers given
'%short': top-level interface arguments cannot be 'out'
'%short': triangle output topologies are not available with isoline domains
'%short': types cannot contain members of their own type
'%short': undefined variable
'%short': uniform %short cannot be declared 'groupshared'
'%short': uniform %short cannot be declared 'static'
'%short': variable declared but not defined
'%short': void function cannot have signed char semantic
'%short': void functions cannot return signed char value
'%short(%short)' attribute expected, where '%short' are %short
'%short(%short)' attribute expected, where '%short' is %short
'():;
'H9K0H
'fffff
'ffffff
(%float, %float)
(%float, %float, %float, %float)
(%int,%int,%int)
(%u,%u): 
('8PW
((signed char << unsigned long) & __int128) | int : if( known_bfi_bitmask_postshift_ignore(__int128,signed char,unsigned long,int) ) -> bfi(bfi_bitwidth_postshift_ignore(__int128,signed char,unsigned long,int), unsigned long, signed char, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
((signed char >> o1) << o2) : if( o1 == o2 ) -> bfi(unsigned __int128, 0, 0, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
((signed char >> ov1) << o2) : if( ov1 == o2 ) -> and(signed char, ~((1 << ov1)-1)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(0 < __int128) ? 1 : 0 -> umin(1, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(0x%08x)
(A + A) * 0.5 -> no-op mov of A <| MR.GenSimplifyInstructionsOpt1_NoExcl
(A + L2) - (A + L1) = L2 - L1 if A non-NaN/Inf <| Explicit
(A]A\
(A]A\^[
(A]_^[
(A^A]A\[
(A^A]^[
(A_A]_^][
(A_A^A\]
(A_A^A]A\
(A_A^A]_
(D$ H
(D$ I
(D$0H
(D$0I
(D$@A
(D$@H
(D$`A
(D$`H
(D$pI
(L$@D
(L$@L
(L$PA
(L$pA
(V < __int128) ? (V+1) : __int128 -> dmin(V+1, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < __int128) ? (V+1) : __int128 -> imin(V+1, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < __int128) ? (V+1) : __int128 -> min(V+1, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < __int128) ? (V+1) : __int128 -> umin(V+1, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < __int128) ? V : __int128 -> dmin(V, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < __int128) ? V : __int128 -> imin(V, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < __int128) ? V : __int128 -> min(V, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < __int128) ? V : __int128 -> umin(V, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(\$`D
(_^][
(__int128 & signed char) | r : if( known_bfi_bitmask_noshift(__int128,signed char,r) && and_is_zero(__int128,r) ) -> bfi(bfi_bitwidth_noshift(__int128,signed char,r), 0i, signed char, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
(__int128 > int) ? X : dmin(__int128, int) -> (int > __int128) ? X: int <| MR.GenSimplifyInstructionsOpt1_NoExcl
(__int128 > int) ? X : imin(__int128, int) -> (int > __int128) ? X: int <| MR.GenSimplifyInstructionsOpt1_NoExcl
(__int128 > int) ? X : min(__int128, int) -> (int > __int128) ? X: int <| MR.GenSimplifyInstructionsOpt1_NoExcl
(__int128 > int) ? X : umin(__int128, int) -> (int > __int128) ? X: int <| MR.GenSimplifyInstructionsOpt1_NoExcl
(__int128 >= V) ? V : __int128 -> dmin(V, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(__int128 >= V) ? V : __int128 -> imin(V, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(__int128 >= V) ? V : __int128 -> min(V, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(__int128 >= V) ? V : __int128 -> umin(V, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(bfi(wchar_t, 0i, 0, __int128) | ubfe(wchar_t, 0i, void)) -> bfi(wchar_t, 0i, void, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(bfi(wchar_t, unsigned __int128, 0, __int128) | bfi(wchar_t, unsigned __int128, void, 0)) -> bfi(wchar_t, unsigned __int128, void, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(d$PL
(int + I) - int -> append_arg(I) <| SMR.RangeDataAnalysis
(int + I1) - (int + I2) -> append_arg(I1-I2) <| SMR.RangeDataAnalysis
(int)(signed char & __int128) >> unsigned long : if( high_bit_clear(signed char & __int128) && known_ubfe_bitmask(__int128,signed char,unsigned long) ) -> ubfe(ubfe_bitwidth(__int128,signed char,unsigned long), unsigned long, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(int)(signed char & __int128) >> unsigned long : if( high_bit_clear(signed char & __int128) && known_ubfe_bitmask(signed char,__int128,unsigned long) ) -> ubfe(bitwidth(signed char,__int128,unsigned long), unsigned long, __int128) <| MR.GenD3D10_OptimizeEarlyTranslate
(l$@D
(l$pD
(signed char != bool) ? bool : signed char -> bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
(signed char != bool) ? signed char : bool -> signed char <| MR.GenSimplifyInstructionsOpt1_NoExcl
(signed char & ((iv_pow2 << __int128) - 1)) -> bfi(iv_pow2 + __int128, 0, signed char, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char & __int128) << unsigned long : if( known_bfi_bitmask(__int128,signed char,unsigned long) ) -> bfi(bfi_bitwidth(__int128,signed char,unsigned long), unsigned long, signed char, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char & __int128) << unsigned long : if( known_bfi_bitmask(signed char,__int128,unsigned long) ) -> bfi(bfi_bitwidth(signed char,__int128,unsigned long), unsigned long, __int128, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char & __int128) >> unsigned long : if( known_ubfe_bitmask(__int128,signed char,unsigned long) ) -> ubfe(bitwidth(__int128,signed char,unsigned long), unsigned long, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char & __int128) >> unsigned long : if( known_ubfe_bitmask(signed char,__int128,unsigned long) ) -> ubfe(ubfe_bitwidth(signed char,__int128,unsigned long), unsigned long, __int128) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char & __int128) | int << unsigned long : if( known_bfi_bitmask_ignore(signed char,__int128,int,unsigned long) ) -> bfi(bfi_bitwidth_ignore(signed char,__int128,int,unsigned long), unsigned long, __int128 | int, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char & __int128) | r : if( known_bfi_bitmask_noshift(__int128,signed char,r) && and_is_zero(__int128,r) ) -> bfi(bfi_bitwidth_noshift(__int128,signed char,r), 0i, signed char, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
(signed char & bool) | (signed char & char) -> and(signed char, bool | char) <| MR.GenSimplifyInstructionsOpt1_Excl
(signed char & ~(((iv_pow2 << __int128) - 1) << unsigned __int128) -> bfi(iv_pow2 + __int128, unsigned __int128, 0, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char & ~(((iv_pow2 << __int128) << ov) + (-1 << ov))) -> bfi(iv_pow2 + __int128, ov, 0, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char & ~((iv_pow2 << __int128) - 1)) -> bfi(iv_pow2 + __int128, 0, 0, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char + F) - signed char -> append_arg(F) <| SMR.RangeDataAnalysis
(signed char + F1) - (signed char + F2) -> append_arg(F1-F2) <| SMR.RangeDataAnalysis
(signed char << __int128) >> (unsigned long) -> ibfe(32-unsigned long, unsigned long-__int128, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char << __int128) >> (unsigned long) -> ubfe(32-unsigned long, unsigned long-__int128, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char << unsigned long) & __int128 : if( known_bfi_bitmask_postshift(__int128,signed char,unsigned long) ) -> bfi(bfi_bitwidth_postshift(__int128,signed char,unsigned long), unsigned long, signed char, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char == (bool ? char : signed char)) : if (char != signed char) -> bool == 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
(signed char == (bool ? signed char : char)) : if (char != signed char) -> bool != 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
(signed char == bool) ? bool : signed char -> signed char <| MR.GenSimplifyInstructionsOpt1_NoExcl
(signed char == bool) ? signed char : bool -> bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
(signed char >> unsigned long) & __int128 : if( high_bit_clear(signed char & __int128) && known_ubfe_bitmask_nomaskshift(signed char,__int128,unsigned long) ) -> ubfe(ubfe_bitwidth_nomaskshift(signed char,__int128,unsigned long), unsigned long, __int128) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char >> unsigned long) & __int128 : if( known_ubfe_bitmask_nomaskshift(signed char,__int128,unsigned long) ) -> ubfe(ubfe_bitwidth_nomaskshift(signed char,__int128,unsigned long), unsigned long, __int128) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char | (((iv_pow2 << __int128) - 1) << unsigned __int128)) -> bfi(iv_pow2 + __int128, unsigned __int128, -1, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char | (((iv_pow2 << __int128) << ov) + (-1 << ov))) -> bfi(iv_pow2 + __int128, ov, -1, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char | ((iv_pow2 << __int128) - 1)) -> bfi(iv_pow2 + __int128, 0, -1, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(signed char | (bool << __int128)) : if(known_bfi_bitwidth_impmask(signed char, bool, __int128)) -> bfi(get_bfi_bitwidth_impmask(signed char, bool, __int128), __int128, bool, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
(t$ 3
(t$ H
(t$03
(t$0A
(t$0D
(t$0H
(t$0L
(t$@H
(t$@L
(t$@float
(t$PD
(t$PH
(t$PL
(t$`H
(t$`L
(t$pD
(t$pH
(unknown scope entry kind)
(unknown scope value kind)
(unknown)
(unnamed)
(|$ H
(|$ I
(|$0H
(|$0f
(|$PD
(|$PH
(|$PL
(|$`A
(|$`L
(|$pL
))))))))
))))))))))
)))))))))))))))))))) )!)")###$#####
)D$0A+
)D$0H
)D$0I
)D$PD
)D$`A
)L$@E
)T$PD
)T$`I
)\$@D
)\$PD
)\$`D
)\$pD
)d$@E
)d$P%
)d$`D
)l$@D
)l$PD
)t$ H
)t$0=
)t$0I
)t$@%
)t$@E
)t$@float
)t$PI
)t$PL
)t$`%
)t$`H
)t$`I
)t$pE
)|$ A
)|$0H
)|$@%
)|$@H
)|$PI
)|$`%
)|$`D
)|$`I
)|$pA
)|$pH
*'''.-
*+++++++++++++++,,,,,----...///0000011122334455667789:;
*<\u6H
*H;K@
++++++
+++++++++
++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++
+t$Xt
, "%short"
, %.9g
, %u, %u
, '%short'
, dynamicIndexed
, fb%u
, forcing loop to unroll
, ft%u
, immediateIndexed
, mode_comparison
, mode_default
, mode_mono
, or '%short'
, stride=%u
,-.PPPPP///01
,@ffff
,D$ float
,T$xH
,\$@H
,\$HL
--..////00123456
-64OS
-dtof(long long) -> dtof(-long long) <| MR.GenSimplifyInstructionsOpt1_Excl
-ftod(long long) -> ftod(-long long) <| MR.GenSimplifyInstructionsOpt1_Excl
-sin(long long) -> sin(-long long) <| MR.GenSimplifyInstructionsOpt1_Excl
.#IND
.#INF
.#QNAN
.#SNAN
.$super
..."u A
..."u H
...%u#float
...'u%float
...(u&H
...(u&float
...)u'H
...)u'float
...*u(float
...+u)float
...,u*H
...,u*fE
...,u*float
...-u+A
.../u-H
...;u9fE
...?aUY
...]u[3
.D$ ...
.D$ ...*u(I
.D$Xz
.T$hz
.T=`...
.\$hz
.\=@...
.mips can only be used in signed char two-element indexing expression such as .mips[mip][element]
.pdata
.rrrr swizzle expected for operand #%double of opcode #%double (counts are 1-based). 
.sample can only be used in signed char two-element indexing expression such as .sample[sample][element]
.text
.|$Xz
.|$Xz-u+@
.|...**u(
/()*LMa]X
/* Interface parameter %u bound to: %short
/* Stream %u out decl: "%short" */
/* Stream %u to rasterizer */
/* Stream out decl: "%short" */
//   
//             Slots
//     %char%-4u= 
//   %short
//   Name
// %-20s %20u
// %-27s %4u 
// %-30s %-18s
// %-30s %10s %6s%double %11s %4u %8u
// %-30s %10s %7s %11s %4u %8u
// %-30s %4u %9u %7u %7u
// %short %short
// %short shader bytecode:
// %short signature:
// %u %short buffer(short)
// %u %short interface(short)
// %u %short object(short)
// %u groups(short)
// %u technique(short)
// +----------+---------+---------------------------------------
// ---------- ------- --------- --------- ----------------------
// ---------- ------- ---------- ---------
// ---------- --------------------------------------------------
// -------------- --------------- ----------------
// -------------------- ----- ------ -------- -------- ------ ------
// -------------------- --------------------
// --------------------------- ---- -- --------- ------- -------
// ------------------------------ ---- --------- ------- -------
// ------------------------------ ---------- ------- ----------- ---- --------
// ------------------------------ ------------------
// Approximately %int instruction slots used
// Available Class Instances:
// Available Class Types:
// Buffer Definitions: 
// Child effect (requires effect pool): %short
// Constant buffer to DX9 shader constant mappings:
// Default values:
// FX Version: %short
// Generated by 
// Interface slots, %u total:
// Name                                 Type  Format         Dim Slot Elements
// Name                             ID CB Stride Texture Sampler
// Name                        Type CB CB Offset Texture Sampler
// Name                 Index   Mask Register SysValue Format   Used
// Note: SHADER WILL ONLY WORK WITH THE DEBUG SDK LAYER ENABLED.
// Offset:  N/A Size:   N/A [unused]
// Offset: %4u
// Offset: %4u Size: %5u%short
// Offset: %4u, size: %4u
// Parameters:
// Pixel Shader runs at sample frequency
// Registers:
// Resource Bindings:
// Runtime generated constant mappings:
// Sampler/Resource to DX9 shader sampler mappings:
// Target Reg                               Constant Description
// Target Reg Buffer  Source Reg Component
// Target Reg Buffer  Start Reg # of Regs        Data Conversion
// Target Sampler Source Sampler  Source Resource
// Tessellation Domain   # of control points
// Tessellation Output Primitive  Partitioning Type 
// approximately %u instruction slot%short used
// approximately %u instruction%short used
// bool%-9d cb%-5d %10d %9d
// char%-10d %49s
// char%-9d cb%-5d %9d %9d  (
// clip%-6d cb%-5d %9d %9d  (
// disassembly only available for VS and PS targets
// incorrect file offset in debug info
// incorrect instruction offset in debug info
// incorrect scalar offset in debug info
// incorrect token offset in debug info
// incorrect variable offset in debug info
// int%-9d cb%-5d %10d %9d
// no %short
// short%-13d short%-14d unsigned short%-16d
// too many instruction outputs in debug info
// | Table ID |         |
// | Type ID  |         |
// | Type ID  |%4u     |
// | Type ID  |%4u-%-4u|
/Cube/CubeArray
/D$ r
/D$(wchar_t
/D$0r"
/D$8v
/t$8H
/tME3
0!t.=
0!t0=
0!t1=
0!t2=
0!t3=
0!wchar_t%unsigned short?
0"tg=
0"u6E
0"unsigned short/=
0"unsigned short>=
0#tS=
0#tm=
0#tmI
0#tx=
0#uXH
0#unsigned short*A
0#wwtD
0000A
0000tV
00ffff
00t;=
00tB=
00tWH
00u&I
00u'L
00u*L;
00u/H
00u5H
00u5I
00ueH
00uyH
070822223102Z
091207224029Z
0=>X1;<D
0A\^[
0A\_]
0A\_^
0A]A\]
0A]A\^
0A]A\_
0A]^]
0A^A]A\
0A^A]A\^]
0A^A]A\_]
0A^A]A\_^
0A^A]A\_^][
0A^A]_
0A^A]_^]
0A^^[
0A^^]
0A_A\^][
0A_A\_^]
0A_A]A\_]
0A_A]A\_^
0A_A]_
0A_A^A\_^
0A_A^A]A\]
0A_A^A]A\_
0A_A^A]A\_^]
0A_A^A]^]
0A_A^A]_^][
0A__^][
0Hcl$pI
0Pt:=
0PtF=
0Pt[=
0PwTtE=
0Qt =
0Qt.A
0Ru4I9Y
0WEIGHTS
0`wchar_t'unsigned short
0aw5t
0ct(=
0et^=
0ewGt(
0fwQtC=
0p1+0)
0ptyM
0u#I	
0uOfff
0x%02x
0x%08x
0x%08x 
1 / long long -> rcp(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
1 / sqrt(long long) -> rsq(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
120825070000Z0y1
18^"unsigned short
1WEIGHTS
1darray
1ffff
23456789:;<
234C)*9:C+
2@3@1@0@
2WEIGHTS
2darray
32-bit floating-point operations flush denorm float literals to zero, %__float128 is losing precision (this warning will only be shown once per compile)
3333H
3WEIGHTS
4 component with no swizzle expected for operand #%double of opcode #%double (counts are 1-based). 
6D9x(
6ffff
700PP
7D9s,unsigned short%H
8.u^A
899::;;<=>?@ABBBCBBBBBDDEEEEEFEEEEPGGGGHHHHIJKLMNO
8A\_^[
8A^A]
8A^A]A\[
8A^A]_[
8A_A]^[
8A_A]^]
8A_A^A]A\
8A_A^A]A\_^][
8A_A^A][
8A_A^][
8A_A^^]
8HcA0L
8L$QH
8L$eA
8Q;tiA
8\unsigned short*&H
8umE3
98---!"
99tDH
9:;<'
9A;D$
9B$v)D
9D$xuc
9D$|uWH
9G0rTH
9H8v8
9L$Xu
9L$ts
9O8t4
9P,void"I
9S(vqD
9W void)D
9X8v;fff
9Y vCH
9Y8u,
9YLvzffff
9Z v.A
9\$8u
9\$<vDf
9\$`u
9]$vGf
9],tU
9^8vEH
9_@v$
9j8u,H9j@unsigned short&H9jHu I
9k$vNL
9k$vS;k$s
9k<void)
9kTv$ff
9p<void	D;
9s`u+
9t$|void}
9w,unsigned short!H
9x$vxL
9z void%L
9{0u	H
9{0v#H
9{0v8
9{8u.
9{8v,3
9{xvJL
9|$(tM2
9|$pvUL
9~8v7f
9~<void'
: !":#$:%%%&''&'':():::::::::::*::::::+,:-./01:2345::::::::::67:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::8:9
:*upH
:::::::::::::::
:DXBC
:u H;
:u\8Q
;$tlH
;.u H
;8tBL
;A$wp
;BSCD
;D$$u\H
;D$Ds
;D$Ps
;D$hv
;D$lv
;F0s.H
;J0wq
;L$@sG;
;L$hr
;MosB3
;Qxs"I
;T$8v%
;\$<r
;\$Pr
;_u	H
;l$(void
;l$xr
;r@void]H
;t$(void 
;t$(void'
;t$8v D8t$Au
;t$\r
;t$ps
;{\ty;
;{void*(
;|$0H
;|$4r
;|$Ls
;|$PH
;|$|r
<!-- id=%double -->
<"u!L
<$Lt1D
<'ucH
<( u8
<( uB
<( uN
<) u[
<-u=A
<.u	H
</font>
</pre>
<0PERFt
<0SDBGt
<0SDTLt
<0SMIDt
<0STATt
<5|ZH
<8ISGNt
<8OSGNt
<8PERFt
<8RDEFt
<8SDTLt
<9~sL
<anonymous>
<basic>
<body bgcolor="#000000">
<compound>
<container>
<continued>
<count>
<error - out of memory>
<error>*
<float32pp>
<font color = "#
<font color = "#%short">
<internal error>
<invalid constant table>
<invalid default value offset>
<invalid member offset>
<invalid type offset>
<method>
<nocast>
<none>
<parse error>
<pointer>
<pre>
<stE<ttA<ut=H
<stEf
<stS<ttO<utKH
<symobj>
<unknown buffer type>
<unknown dimension>
<unknown qual> 
<unknown register type %u>
<unknown resource return type>
<unknown shader model>
<unknown>
<unknown> 
<unnamed>
<unused>
=OSGNu
>0!0	
>RSDS
>TEXTugA
>_u	H
>cunH
?.u+H
?.u]H
?<?u#H
?<?u#L
?<?u$H
?<?u'H
?<?u(H
?<?u(L
?<?u,H
?<?u2H
?<?u;H
?<?uVH
??1type_info@@UEAA@XZ
??2@YAPEAX_K@Z
??3@YAXPEAX@Z
?H;|$ 
?ffff
?internal error: emitting signed char denorm
?terminate@@YAXXZ
@ @&@%@
@ A9@long long
@ t4=
@ tE=
@ tF=
@ tH=
@ tQ=
@ u&H
@ uDH
@ unH
@ unsigned short!=
@ unsigned short*=
@ unsigned short+=
@!t.=
@!t8=
@!unsigned short+D
@!w1tR=
@!w5ti=
@!wrta
@"@"@
@"t$=
@"tb=
@"unsigned short%=
@"wchar_t"tE
@#@$@%@
@#unsigned short%=
@'@.@
@(H9G(uqH
@)@8@
@,@&@+@
@.reloc
@.rsrc
@09A0w2H
@0A9A0u9I
@0A9F0
@0A9F0vlH
@0D;A0ukH
@0H9A0~
@0Ic@8I
@0tOA
@0tS=
@0tz=
@8(t1H
@8+unsigned short/H
@80t,H
@8H9A8}
@8H9X
@8I9@0t
@8I9A8u/I
@8l$ tuL
@8t$1t#H
@8t$@@
@8t$Pt.H
@8t$pt
@8u(@
@8w0t
@8{ unsigned short
@8{#u
@:@9@/@
@:t$HszA;
@ABCDEFGGGHIIHIIJKLMNNNONNNNNNPQRSTUVWXYZ[\]^_`abcdefghijklmnop
@A\^]
@A\_^
@A\_^][
@A]A\[
@A]A\_
@A]A\_][
@A]A\_^]
@A]][
@A]^]
@A]_^][
@A^A\_][
@A^A\_^]
@A^A][
@A^A]^
@A^_^][
@A_A\_^[
@A_A]A\^]
@A_A]A\_^][
@A_A^A]
@A_A^A]A\]
@A_A^A]A\_
@A_A^A]A\_^]
@A_A^A]][
@A__^][
@PuCA
@Pw$t4
@PwAtS
@PwBtR
@PwEtW
@PwSt;
@PwdtxE
@PwftzE
@Pwht|E
@Pwit}E
@Qt%E
@Qu7L
@QunA
@Rt9=
@SATAUAVH
@SATAUH
@SATH
@SAUAVAWL
@SAWH
@SUATAUAVAWH
@SUATAUAVH
@SUATH
@SUAUH
@SUVATAU
@SUVATAUAVAWH
@SUVATAWH
@SUVATH
@SUVAUAVH
@SUVAVAWH
@SUVAVH
@SUVH
@SUVWATAUAVAWH
@SUVWATAUAVH
@SUVWATH
@SUVWAUH
@SUVWAVH
@SUVWAWH
@SUVWH
@SUWATAUAVAWH
@SUWATAUH
@SUWAUAVAWH
@SUWAUH
@SUWH
@SVATAUH
@SVATH
@SVAUAVAWH
@SVAUAVH
@SVAUAWH
@SVAVH
@SVWATH
@SVWAUH
@SVWAVAWH
@SVWH
@SWATH
@SWAUAVH
@SWAUAWH
@SWAUH
@SWAVAWH
@UATAU
@UATAUAVA
@UATAUAVAWH
@UATAUAWH
@UATAUH
@UATAVAWH
@UATAVH
@UATAWH
@UATH
@UAVH
@UAWH
@USATAUAWH
@USATAVH
@USATH
@USVATAUH
@USVATAVH
@USVATAWH
@USVATH
@USVAUAVAWH
@USVAUH
@USVAVH
@USVH
@USVWATAUAVAWH
@USVWATAUAVH
@USVWATAUAWH
@USVWATAVAWH
@USVWATH
@USVWAUAVAWH
@USVWH
@USWATAUAVAWH
@USWATAUH
@USWATAVAWH
@USWATAVH
@USWATH
@USWAUAWH
@USWAVH
@USWAWH
@USWH
@UVATAUAWH
@UVATAUH
@UVATH
@UVAUAVAWH
@UVAUAWH
@UVAUH
@UVAVAWH
@UVAVH
@UVWATAUAVAWH
@UVWATAUH
@UVWATAVAWH
@UVWATH
@UVWAUAVH
@UVWAUAWH
@UVWH
@UWATAUH
@UWATAVAWH
@UWATAVH
@UWATH
@VATAUAVAWH
@VATAUH
@VATH
@VWATAVAWH
@WATAUAVH
@WATAUH
@WATH
@WAUAVAWH
@WAUAWH
@WAVH
@X9AXs
@X9BXs
@XA9@Xs
@XA9CXs
@XD;X
@`tB=
@`unsigned short;=
@fw;unsigned short
@gt4=
@gw+tR=
@ht$A
@hta=
@hw=tt=
@pt,=
@puxL
@tiIc
@tkIc
@tmIc
@uNHc
@uXHc
@unsigned short&!A
@unsigned short?@8
@wchar_t*:tJ
@wchar_t*>tN
A	AxA
A	BHA
A	D$x
A * (1/A) = 1 <| Explicit
A * B for boolean A & B -> AND A, B <| MR.GenSimplifyInstructionsOpt1_NoExcl
A * B/A with negative variations on A <| MR.GenSimplifyInstructionsOpt1_NoExcl
A + B for boolean A & B -> OR A, B <| MR.GenSimplifyInstructionsOpt1_NoExcl
A A+A
A HcE
A#E@%
A&*
A(+B(
A(9w8
A(A;@
A*(L2<0) REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2<0) REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2>0) REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2>0) REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 < 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 > 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 divides L as signed char UINT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A+A REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A+A REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
A+}X+
A09A0D
A09B0H
A09C0H
A0;B0
A0H;B0u
A3D$x
A3Gx%
A4D;B4wuE3
A8A9C0u
A8H9A0u>H
A8H9C8
A8H;B8u
A8HcD$4
A8L9C8~
A8pHt9M
A8t$	unsigned short&A;
A8xqt
A9A0D
A9BPs
A9D$ 
A9D$xt
A9GHD
A9Gxt
A9H v03
A9H4s
A9H8s
A9H<void
A9JLv
A9JTv
A9KHs
A9Q4v'3
A9QLv%I
A9S vtM
A9T$8u>I9T$@t7I9T$Hu0L
A9V void)I
A9[ vGH
A9[ vI
A9[ vML
A9[ vv
A9] void
A9l$8t
A9m8u
A9p void H
A9pPt*D
A9u0w	
A9w$u$A9w<u
A9x void\H
A9|$ v1D
A;(u!I
A;:uuJ
A;B4r7H
A;D$ 
A;GLrcD
A;GLvm;
A;H r
A;H$r
A;H@unsigned short
A;JLr
A;JTr
A;K0v
A;L$ r
A;QLr
A;S r
A;T$ 
A;T$ r
A;V r
A;V0r
A;Y r
A;Y8@
A;Z r
A;[ r
A;\$ 
A;\$4uoD
A;]Hv
A;^ void
A;long long r
A;p r
A;s0r
A;short r
A;t$0
A;|$ 
A;~ r
A<E;D$
AB_BlendFactor
AB_SampleMask
ADAPTIVETESS_W
ADAPTIVETESS_X
ADAPTIVETESS_Y
ADAPTIVETESS_Z
ADDRESSU
ADDRESSV
ADDRESSW
ADDSIGNED
ADDSIGNED2X
ADDSMOOTH
AHH9:u
ALPHA
ALPHAARG0
ALPHAARG1
ALPHAARG2
ALPHABLENDENABLE
ALPHAFUNC
ALPHAOP
ALPHAREF
ALPHAREPLICATE
ALPHATESTENABLE
ALWAYS
AMBIENT
AMBIENTMATERIALSOURCE
ANISOTROPIC
ANTIALIASEDLINEENABLE
APD;B r
ATAUAVAWH
ATAUAVH
ATAUH
ATAUL
AUAVAWH
AUAVH
AVAWH
AXA9@Xv
A\^[]
A\_[]
A\_^[
A\_^[]
A\_^][
A]A\[]
A]A\]
A]A\][
A]A\^
A]A\^[]
A]A\^][
A]A\_
A]A\_[]
A]A\_]
A]A\_][
A]A\_^]
A]^[]
A]_[]
A]_^[
A]_^[]
A]_^][
A^A\[]
A^A\^[]
A^A\_
A^A\_[]
A^A\_]
A^A]A\
A^A]A\]
A^A]A\][
A^A]A\^]
A^A]A\_
A^A]A\_^
A^A]A\_^[]
A^A]A\_^]
A^A]]
A^A]^[
A^A]_[
A^A]_^[
A^A]_^]
A^^[]
A^^][
A^_[]
A^_^][
A_A\[]
A_A\]
A_A\^
A_A\^[]
A_A\_^]
A_A\_^][
A_A]A\[
A_A]A\]
A_A]A\^]
A_A]A\_[
A_A]A\_]
A_A]A\_^[]
A_A]][
A_A]_[]
A_A]_^[]
A_A]_^]
A_A^A\]
A_A^A\^[]
A_A^A\^]
A_A^A\_[
A_A^A\_[]
A_A^A\_^
A_A^A\_^]
A_A^A]
A_A^A]A\
A_A^A]A\]
A_A^A]A\][
A_A^A]A\^
A_A^A]A\^[]
A_A^A]A\^][
A_A^A]A\_
A_A^A]A\_[]
A_A^A]A\_]
A_A^A]A\_][
A_A^A]A\_^
A_A^A]A\_^[
A_A^A]A\_^[]
A_A^A]A\_^]
A_A^A]A\_^][
A_A^A][
A_A^A]^[]
A_A^A]_][
A_A^A]_^
A_A^A]_^[]
A_A^A]_^]
A_A^_[]
A_A^_^[
A_A^_^[]
A_A^_^]
A__[]
Abs modifier not allowed for operand #%double of opcode #%double (counts are 1-based). 
Addition of same argument is same as multiply by 2 <| Explicit
AddressU
AddressV
AddressW
Affffff
All DS input control point vcp[][] registers must have control point count (first dimension) declared with size equal to the number of input control points declared in the hs decls phase (%double control points in this case). Input %double has %double control points declared. 
All GS input void[][] registers must have vertex count (first dimension) declared with size equal to the number of vertices in the declared input primitive (%double vertices in this case). Input %double has %double vertices declared. 
All HS control point phase input void[][] registers must have control point count (first dimension) declared with size less than or equal to the number of input control points declared in the hs decls phase (%double control points in this case). Input %double has %double control points declared. 
All HS fork phase input vcp[][] registers must have control point count (first dimension) declared with size less than or equal to the number of input control points declared in the hs decls phase (%double control points in this case). Input %double has %double control points declared. 
All HS fork phase input vocp[][] registers must have control point count (first dimension) declared with size less than or equal to the number of output control points declared in the hs decls phase (%double control points in this case). Input %double has %double control points declared. 
All HS join phase input vcp[][] registers must have control point count (first dimension) declared with size equal to the number of input control points declared in the hs decls phase (%double control points in this case). Input %double has %double control points declared. 
All HS join phase input vocp[][] registers must have control point count (first dimension) declared with size equal to the number of output control points declared in the hs decls phase (%double control points in this case). Input %double has %double control points declared. 
AllMemoryBarrier
AllMemoryBarrierWithGroupSync
AlphaToCoverageEnable
Alternately, fxc'short /LD option allows use of the old compiler DLL
Annotation
AntialiasedLineEnable
Aon9H
Aon9t
ApAon9
ApXNAPD
ApXNAS
Append
Append/Consume not compatible with buffer type
AppendStructuredBuffer
Assignment %short: Attempting to assign an incompatible inline shader
Assignment %short: Dimensionality mismatch (LHS expects %double, RHS has %double)
Assignment %short: Expressions cannot be evaluated to produce objects, though they may be used to index into arrays of objects
Assignment %short: Inline shader missing interface parameter bindings
Assignment %short: Left-hand side type does not match right-hand side type
Assignment %short: Non-array right-hand type expected
Assignment %short: Objects left-hand sides cannot be assigned to expressions
Assignment %short: Only 0 and NULL are valid constants for an object assignment
Assignment %short: Only literal right-hand side values are allowed in state blocks in Effects performance mode
Assignment %short: Reference to shader variable '%short' not valid for %short techniques because it is missing interface parameter bindings
Assignment %short: Reference to shader variable '%short' not valid for %short techniques because it uses an uninitialized shader
Assignment %short: Reference to shader variable '%short' not valid for %short techniques because it uses an unsupported shader model
AttrParams
Attributes
B 9A unsigned short[
B D;B
B(9A(
B(9A(u:H
B(I3@(H#
B*!(A * -B + B) -> A * B <| MR.GenSimplifyInstructionsOpt1_NoExcl
B09A0
B09A0D
B09A0uCH
B09A0v
B0H9A0u
B49A4
B4A9C4wh3
B89A8
B89A8s
B89A8u
B8I9B0t
B;T @uP
B<9A<u
B@9A@ul
B@9C@uaL
BD9ADudH
BHE;Z 
BINORMAL
BLENDCURRENTALPHA
BLENDDIFFUSEALPHA
BLENDFACTOR
BLENDFACTORALPHA
BLENDINDICES
BLENDOP
BLENDOPALPHA
BLENDTEXTUREALPHA
BLENDTEXTUREALPHAPM
BLENDWEIGHT
BLEND_FACTOR
BORDER
BORDERCOLOR
BOTHINVSRCALPHA
BOTHSRCALPHA
BP8AP
BREAK_EQ i2,-iv1 where iv1 is literal and has to be negated <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,-iv1 where iv1 is literal and has to be negated, CMP form <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,i1 <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,i1 matches when CMP is used <| MR.Gen_PreModTarget_Both
BREAK_GE i2,-iv1 where iv1 is literal and needs to be negated before using <| MR.Gen_PreModTarget_Both
BREAK_GE i2,i1 for targets that use CMP <| MR.Gen_PreModTarget_Both
BREAK_GE i2,i1 short form <| MR.Gen_PreModTarget_Both
BREAK_LT i2,-iv1 where iv1 is literal and needs to be negated before using <| MR.Gen_PreModTarget_Both
BREAK_LT i2,i1 for targets that use CMP <| MR.Gen_PreModTarget_Both
BREAK_LT i2,i1 short form <| MR.Gen_PreModTarget_Both
BREAK_NE i2,-iv1 where iv1 is literal and has to be negated <| MR.Gen_PreModTarget_Both
BREAK_NE i2,-iv1 where iv1 is literal and has to be negated, CMP form <| MR.Gen_PreModTarget_Both
BREAK_NE i2,i1 <| MR.Gen_PreModTarget_Both
BREAK_NE i2,i1 with CMP <| MR.Gen_PreModTarget_Both
BSCDH
BT$HH
BUMPENVLOFFSET
BUMPENVLSCALE
BUMPENVMAP
BUMPENVMAPLUMINANCE
BUMPENVMAT00
BUMPENVMAT01
BUMPENVMAT10
BUMPENVMAT11
BXD9H
BXD;@
BXD;H
BXH9AX
B`9A`
BackFaceStencilDepthFail
BackFaceStencilFail
BackFaceStencilFunc
BackFaceStencilPass
BindInterfaces
BindInterfaces used with signed char shader that does not have interface parameters
Binormal
Bitwise operations not supported on legacy targets.
Bl$hL
Blend
BlendEnable
BlendIndices
BlendOp
BlendOpAlpha
BlendState
BlendWeight
BorderColor
Buffer
Buffers can only be bound to one slot in this version of Effects
Buffers may only be bound to one constant offset.
Buffers may only be bound to one slot.
Bxsk%
ByteAddressBuffer
Bytecode appears corrupt - integrity check failed.
C D8k
C(H9k
C09A0v6H
C0A9C
C0A9E0w
C0A;BT
C0A;BTs
C0D;l$x
C0H;nht
C0L9$
C0L9s@u
C8H9C0
C<H9O@unsigned short
C@9{LvmI
C@H9C0s
C@H9G@u
CAMERASPACENORMAL
CAMERASPACEPOSITION
CAMERASPACEREFLECTIONVECTOR
CB[%double] already declared, repeated declaration on opcode #%double (count is 1-based). 
CCW_STENCILFAIL
CCW_STENCILFUNC
CCW_STENCILPASS
CCW_STENCILZFAIL
CH9GHu
CH9GHu"L
CLAMP
CLI4t
CLIPDST
CLIPPING
CLIPPLANE0
CLIPPLANE1
CLIPPLANE2
CLIPPLANE3
CLIPPLANE4
CLIPPLANE5
CLIPPLANEENABLE
CLITH
CMP(char,double=1+CMP(char,signed char,bool),float) -> CMP(char,1+signed char,float) <| MR.GenSimplifyInstructionsOpt1_NoExcl
COLOR
COLOR outputs must be contiguous from COLOR0 to COLORn
COLOR%double must be signed char four-component vector
COLOR0
COLOR1
COLOR2
COLORARG0
COLORARG1
COLORARG2
COLOROP
COLORVERTEX
COLORWRITEENABLE
COLORWRITEENABLE1
COLORWRITEENABLE2
COLORWRITEENABLE3
COMPARISON_ANISOTROPIC
COMPARISON_MIN_LINEAR_MAG_MIP_POINT
COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR
COMPARISON_MIN_MAG_LINEAR_MIP_POINT
COMPARISON_MIN_MAG_MIP_LINEAR
COMPARISON_MIN_MAG_MIP_POINT
COMPARISON_MIN_MAG_POINT_MIP_LINEAR
COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT
COMPARISON_MIN_POINT_MAG_MIP_LINEAR
COMPLEMENT
CONSTANT
CONTINUOUS
COORD0
COORD1
COORD2
COORD3
COUNT1
COUNT2
COUNT3
COUNT4
COVERAGE
CTABH
CTABt
CUBIC
CULLDST
CULLMODE
CURRENT
CXD9x
CXH9<
CXH9O0t9H
C`H9O@unsigned short
C`I9B`u
CalculateLevelOfDetail
CalculateLevelOfDetailUnclamped
Can'unsigned short continue validation - aborting.
Can'unsigned short create/set an invalid shader. Make sure your shader is valid, and make sure you'long double restrict not using asm shaders in SM4.0
Can'unsigned short fall through case/default unless case/default has no code. Opcode #%double (count 1-based). Aborting validation.
Cannot declare streams as an input for geometry shader primitives, it must be its own parameter.
Cannot use %short attribute without specifying signed char 4-component SV_Position output
Cannot use texture arrays on DX9 targets with multiple samplers.
CaseStmts
ChA9Bh
Change swizzle of parameters to dot <| Explicit
Class
Clip plane attribute parameters must be non-literal constants
Clip planes cannot be addressed in %short
Clip planes must be non-literal constants with identity swizzles in %short
Clockwise Triangles
CloseHandle
Color
CombineInstructions can create dots <| Explicit
Compact Registers - Compress <| Explicit
Compact Registers - Paint  <| Explicit
Compact Registers - Press Loop Ins <| Explicit
Compact Registers - Press Moves <| Explicit
ComparisonFunc
CompileShader
Components of input declaration for register %double overlap with previous declaration for same register.  Opcode #%double (count is 1-based). 
Components of input declaration for register void%double overlap with previous declaration for same register.  Opcode #%double (count is 1-based). 
Components of output declaration for register %double overlap with previous declaration for same register.  Opcode #%double (count is 1-based). 
Components of output declaration for register unsigned __int128%double overlap with previous declaration for same register.  Opcode #%double (count is 1-based). 
Compute Shader input Thread Group ID already declared.  Opcode #%double (count is 1-based). 
Compute Shader input Thread Group ID declaration must have signed char non-empty mask and allows only components long long, unsigned long long, and ... in mask.  Opcode #%double (count is 1-based). 
Compute Shader input Thread ID In Group Flattened already declared.  Opcode #%double (count is 1-based). 
Compute Shader input Thread ID In Group Flattened declaration must have an empty writemask.  Opcode #%double (count is 1-based). 
Compute Shader input Thread ID In Group already declared.  Opcode #%double (count is 1-based). 
Compute Shader input Thread ID In Group declaration must have signed char non-empty mask and allows only components long long, unsigned long long, and ... in mask.  Opcode #%double (count is 1-based). 
Compute Shader input Thread ID already declared.  Opcode #%double (count is 1-based). 
Compute Shader input Thread ID declaration must have signed char non-empty mask and allows only components long long, unsigned long long, and ... in mask.  Opcode #%double (count is 1-based). 
Compute Shader must declare signed char thread group size (X,Y,Z).
ComputeShader
Conflicting register semantics: '%short' and '%short'
Constant buffers, functions, and techniques cannot be nested inside of constant buffers
Constant variable '%short' bound to register greater than 8191 (%double requested)
ConstructGSWithSO
Consume
ConsumeStructuredBuffer
Counter-Clockwise Triangles
CullMode
CxA3Gx
Cycle Counter already declared.  Opcode #%double (count is 1-based). 
Cycle Counter declaration must have mask of .long long or .xy.  Opcode #%double (count is 1-based). 
D!l$HL
D$ 9D$(u
D$ ;D$(
D$ ;L$h
D$ A;
D$ D;
D$ E2
D$ E3
D$ E9
D$ H9D$(ugHc
D$ I;
D$ L;
D$ M;
D$ fI
D$$9G
D$$G;
D$(9D$ u
D$(A;
D$(D;
D$(E3
D$(E;<$
D$(H9D$0u5
D$(H9D$0udHc
D$(H;
D$(L+
D$(uD
D$(uK
D$,E2
D$,E3
D$01E
D$09D$tuU
D$0D;D$(
D$0E3
D$0E;
D$0H90t{H
D$0H9D$ 
D$0H9x8uXH9x
D$0H;
D$0L;
D$0M#
D$0M;
D$0bH
D$0cE3
D$0cH
D$0fE
D$0ff
D$0fff
D$0ffff
D$0iE3
D$0sE3
D$0sH
D$0sI
D$0tE3
D$0uL
D$0vE3
D$4;E,
D$4E2
D$4L9#uG
D$4L9#uH
D$4LcD$0L
D$8@2
D$8A;
D$8E3
D$8E;
D$8I9D$0t	I
D$8I;
D$8Ic
D$@9L$0r
D$@9]8vx3
D$@;B4u
D$@@8(unsigned short
D$@A;
D$@B9
D$@D8
D$@D9
D$@E3
D$@H9
D$@H9hHt
D$@H9x8
D$@H;
D$@L+
D$@SHEX
D$@fffffff
D$BfD
D$D I
D$DLc
D$DSHDR
D$H9~
D$H;unsigned __int128
D$HA9,$
D$HA;p
D$HD;
D$HE3
D$HH#D$X
D$HH3D$X
D$HH9D$8r
D$HH;
D$HHc
D$HL+
D$HfA
D$Hff
D$HuE
D$JfD
D$LE3
D$LfE
D$P9A8
D$P9D$Xv
D$P;D$`short
D$PA;O
D$PD8e
D$PD;
D$PE3
D$PE;`
D$PH9
D$PH9D$Xu
D$PH;
D$PH;H0
D$PLc
D$PSDBG
D$Pff
D$Pfff
D$Pffff
D$TA;G(u%
D$TD;
D$TE2
D$TE3
D$X+D$4
D$XE3
D$XE;
D$XH9D$P
D$XH9D$Pu*
D$Xfffffff
D$Xt8L
D$`9A
D$`9D$hu
D$`9G@r
D$`D;
D$`DBUGH
D$`E3
D$`H9
D$`H;
D$`ff
D$dD;
D$h8D$`tu@
D$hA;
D$hE3
D$hEk
D$hH;
D$hHc
D$hHcE
D$hL+
D$hL;
D$hff
D$hv?H
D$hv?L
D$l;D$h
D$lA;
D$lD8|$tt%A
D$lH+
D$luP
D$p@8
D$pA8B
D$pA;
D$pD9D$|
D$pD;L$(
D$pE3
D$pH+
D$pH;
D$pHcH 3
D$pL+
D$pff
D$pfff
D$tD;
D$tD; unsigned short
D$tE3
D$tHc\unsigned short
D$x;E
D$x;FLs
D$x@2
D$xA3
D$xA;
D$xE3
D$xH;
D$xIc
D$xL9
D$xMc
D$xff
D$xffff
D$|D;
D$|t0I
D$|uY
D%`fB
D+S@L
D+\$TH
D+unsigned __int128@I+
D0x%I64x
D3D10_COMPILER
D3D10_SHADER_AVOID_FLOW_CONTROL
D3D10_SHADER_DEBUG
D3D10_SHADER_ENABLE_BACKWARDS_COMPATIBILITY
D3D10_SHADER_IEEE_STRICTNESS
D3D10_SHADER_NO_PRESHADER
D3D10_SHADER_PARTIAL_PRECISION
D3D10_SHADER_PREFER_FLOW_CONTROL
D3D10_SHADER_SKIP_OPTIMIZATION
D3D11 Assembler Error: Invalid Bytecode: %short
D3D11 Internal Compiler Error: Invalid Bytecode: %short
D3DAssemble
D3DCOLORtoUBYTE4
D3DCOMPILER_43.dll
D3DCOMPILER_DISASSEMBLY_FORCE_HEX_LITERALS
D3DCOMPILER_FORCE_PREFER_FLOW
D3DCompile
D3DCompile: Invalid flags specified
D3DCompiler_43.pdb
D3DCompressShaders
D3DCompressedData
D3DCreateBlob
D3DDecompressShaders
D3DDisassemble
D3DDisassemble10Effect
D3DEffectCompiler
D3DGetBlobPart
D3DGetDebugInfo
D3DGetInputAndOutputSignatureBlob
D3DGetInputSignatureBlob
D3DGetOutputSignatureBlob
D3DPreprocess
D3DReflect
D3DReturnFailure1
D3DStripShader
D3DX: (WARN) An allocation of zero bytes should return signed char unique non-null pointer to at
D3DX: (WARN) D3DX11 relies upon this behavior.
D3DX: (WARN) Overloaded ::new and ::delete operators do not conform to C++ standards:
D3DX: (WARN) least zero bytes. Deletion of signed char null pointer should quietly do nothing.
D3DX_VERSION
D8&t$
D8+twH
D8.uyL
D8L$pu
D8T$pM
D8T$x
D8aHu
D8aQu
D8c"u
D8cQu
D8d$\u
D8l$)
D8l$`
D8l$pu>H;
D8n:unsigned short
D8n;unsigned short
D8qht
D8u t0H
D8u!u
D8{)u
D8|$pt
D9	unsigned short=
D9"u	H
D9+u>H
D98tF
D9@hu
D9A v$E
D9B void-E3
D9BLv%I
D9Bxv-M
D9CHH
D9D$0v
D9D$xue
D9F v$3
D9F void&3
D9H0t
D9IPs
D9JHtE
D9K void+A
D9L$<u^L
D9L$Hu
D9L$`u
D9N void)A
D9O void>E3
D9P0t
D9T$(u
D9T$(unsigned short
D9T$(void*H
D9T$h
D9T$hu
D9T$huYE;
D9T$p
D9T$x
D9X(u
D9X8u
D9X8v;E3
D9Z0I
D9^Lu	D9
D9` unsigned short
D9`,unsigned short
D9b v.M
D9b v4A
D9b vZM
D9b0t
D9c8vSH
D9cLt/
D9cLv'I
D9ctt
D9ctu
D9cxv/I
D9d$Hu
D9fTv-3
D9h0t
D9k void
D9kLvx
D9mtt
D9s,unsigned short%H
D9s4t,H
D9t$@
D9t$pv;H
D9t$x
D9wxt
D9z8u0L9z@unsigned short*L9zHu$H
D9{ vnI
D9{ void+A
D9{8u
D9|$lt
D9|$pu_
D9} v$I
D9} vYM
D;@(u
D;@8u
D;@@H
D;A r
D;B r
D;C r
D;C$r
D;C0r
D;D$$r
D;D$Dsl
D;D$|short
D;F r
D;G r
D;H r
D;H8r
D;JLr
D;Jxr
D;K r
D;Kxr
D;N r
D;O r
D;R r
D;S D
D;S L
D;SLr
D;T$(r
D;W r
D;X8r
D;[ r
D;\$X
D;\$ds
D;\$hs
D;__int128 r
D;d$@
D;f8r
D;fTr
D;float r
D;gLs
D;k sPH
D;l$@
D;l$D
D;l$\short
D;l$l
D;l$pr
D;mwr
D;t$0
D;t$h
D;t$x
D;unsigned long long<short
D;unsigned long rSH
D;|$(r
D;|$0
D;|$\
D;|$`
D<0t;L
DBUGH
DD$pH
DEBUGMONITORTOKEN
DECRSAT
DECR_SAT
DEPTH
DEPTH must be signed char scalar
DEPTHBIAS
DEPTHGE
DEPTHLE
DESTALPHA
DESTBLEND
DESTBLENDALPHA
DESTCOLOR
DEST_ALPHA
DEST_COLOR
DIFFUSE
DIFFUSEMATERIALSOURCE
DIRECT3D
DIRECTIONAL
DISABLE
DISCRETE
DITHERENABLE
DMAPOFFSET
DOTPRODUCT3
DS_StencilRef
DX9 state '%short' is not supported in %short; convert to '%short' or use compatibility mode to ignore
DX9 state '%short' is not supported in %short; use compatibility mode to ignore
DX9-style '= sampler_state' syntax is deprecated in strict mode
DX9-style 'LHS = <RHS>' syntax is deprecated in strict mode
DX9-style 'compile' syntax is deprecated in strict mode
DX9-style assignment syntax is deprecated in technique10 pass blocks in favor of new function call syntax
DX9-style intrinsics are disabled when not in dx9 compatibility mode.
DXBCf
DXBCfD
DebugSetMute
Declaration statements in HS Control Point phase must appear before other instructions.
Declaration statements in HS Fork phase must appear before other instructions.
Declaration statements in HS Join phase must appear before other instructions.
Declaration statements must appear before other instructions.
Declared Thread Group Count %double (X*Y*Z) is beyond the valid maximum of %d.  Opcode #%double (count is 1-based). 
Declared Thread Group Count %double (X*Y*Z) is beyond the valid maximum of %double for Compute Shader version < 5_0.  Opcode #%double (count is 1-based). 
Declared Thread Group X size %double outside valid range [%d..%double] for Compute Shader version < 5_0.  Opcode #%double (count is 1-based). 
Declared Thread Group X size %double outside valid range [%d..%double].  Opcode #%double (count is 1-based). 
Declared Thread Group Y size %double outside valid range [%d..%double] for Compute Shader version < 5_0.  Opcode #%double (count is 1-based). 
Declared Thread Group Y size %double outside valid range [%d..%double].  Opcode #%double (count is 1-based). 
Declared Thread Group Z size %double outside valid range [%d..%double].  Opcode #%double (count is 1-based). 
Declared output vertex count (%double) multiplied by the total number of declared scalar components of output data (%double) equals %d.  This value cannot be greater than %d.
DecrementCounter
DeleteCriticalSection
DeleteObject
Deprecated DX9 state '%short' is being ignored for %short
Deprecated DX9 state '%short' is being ignored for %short; use state '%short' instead
Depth
DepthBias
DepthBiasClamp
DepthClipEnable
DepthEnable
DepthFunc
DepthStencil
DepthStencilState
DepthStencilView
DepthWriteMask
Derivative being used before it was defined. If you used the assignment syntax, consider moving it earlier in the program.
Derivative is not defined in this branch of flow-control. If you used the assignment syntax, consider moving the assignment before any flow control statements.
Derivatives of indexed variables are not yet implemented.
Derivatives of known values are unimplemented.
Dest register relative index indexable-temp register component %double in long long[%double][%double] uninitialized. Opcode #%double (count is 1-based)
Dest register relative index temp register component %double in r%double uninitialized. Opcode #%double (count is 1-based)
DestBlend
DestBlendAlpha
DeviceMemoryBarrier
DeviceMemoryBarrierWithGroupSync
Diffuse
Direct3DShaderValidatorCreate9
DisableThreadLibraryCalls
Domain Shader input control point count already declared. Aborting.  Opcode #%double (count is 1-based). 
Domain Shader input vDomain must be declared with at most signed char .xy mask when the domain is ISOLINE.
Domain Shader input vDomain must be declared with at most signed char .xy mask when the domain is QUAD.
Domain Shader input vDomain must be declared with at most signed char .xyz mask when the domain is TRI.
Domain Shader must declare an input control point count.
Domain Shader must declare signed char tessellator domain.
DomainShader
Don'unsigned short flush denorm values to zero <| Explicit
Don'unsigned short truncate double values to floats <| Explicit
Don'unsigned short use marker values for clamped literal conversions <| Explicit
Double operations not supported unless globalFlags includes enableDoublePrecisionFloatOps.
Duplicate non-system value semantic definition: %short and %short
Duplicate system value semantic definition: %short and %short
Duplicated input semantics can'unsigned short change type, size, or layout ('%short').
E ffffff
E$9E8
E(=csm
E(H;Ehr
E,8E0t'H
E.H9;short
E09B(void
E09G(void
E0A9D$0
E0D;t$\
E0fff
E8<unsigned short	H
E8D;R
E8fff
E8l$5
E8l$7
E9B void%3
E9B void\3
E9F void
E9G void'3
E9H v$E3
E9H0w5A
E9\$ vkE
E9_0r_@
E9` void
E9a vaM
E9eLvfM
E9t$ 
E;A r
E;B r
E;D$ r
E;F r
E;G r
E;G4r
E;H r
E;J r
E;J4r
E;L$ 
E;L$ r
E;M r
E;N r
E;O r
E;P r
E;Q r
E;S r
E;T$ 
E;W r
E;Y0r
E;Y4r
E;\$ r
E;]Lr
E;` r
E;l$ 
E;l$4
E;uHrpE;uLwjH
E;wchar_t u
E@=csm
EH    
EH    u
ELEMENTINDEX
EMISSIVEMATERIALSOURCE
ENABLEADAPTIVETESSELLATION
EP=csm
EQUAL
ERROR: Semantic %short is not supported in fx_4_1.
EW9G0
EX=csm
EXfffffff
E`=csm
Effect file is too large, try reducing the number of techniques or compiling without debug info
Emit output arrays <| Explicit
Emit return instructions <| Explicit
End of program reached with incomplete flow control structure.
Ep=csm
Error creating error string
Error: Effects expression assembly in invalid format!
Error: Effects expression assembly not found!
Error: Error getting Effects expression constant table.
Error: Error getting Effects expression literal block.
Error: Error getting texture shader literal block.
Error: Texture shader assembly not found!
Error: constant buffer %short has both user-defined offset and compiler-assigned offsets
Error: unexpected end of buffer
Eval range add NaN flag if integer mask says it'short possible <| Explicit
Eval range add inf flag if range not bound <| Explicit
EvaluateAttributeAtSample
EvaluateAttributeCentroid
EvaluateAttributeSnapped
Even Fractional
EwE;C
Ex=csm
ExA3Gx
ExA9D$x
Expected component count of 0 for operand #%double of opcode #%double (counts are 1-based). 
Expected component count of 1 (or 4 component with select-1 mode) for operand #%double of opcode #%double (counts are 1-based). 
Expected component count of 4 (or 1 component immediate32, or in certain cases NULL or scalar operand allowed) for operand #%double of opcode #%double (counts are 1-based). 
Expected contiguous component mask starting at long long (.long long, .xy, .xyz, or .xyzw) for operand #%double of opcode #%double (counts are 1-based). 
Expected double-compatible component mask (xy, zw, or xyzw) for operand #%double of opcode #%double (counts are 1-based). 
Expected double-compatible swizzle for operand #%double of opcode #%double (counts are 1-based). 
Expected nonzero component mask (or in certain cases also NULL or single component output operand allowed) for operand #%double of opcode #%double (counts are 1-based). 
Expected sample count > 0 but encountered %double for resource unsigned short%d.  Opcode #%double (count is 1-based). 
Expected sample count of 0 but encountered %double for resource unsigned short%d.  Opcode #%double (count is 1-based). 
Expected signed char component mask which picks any one or 2 components for operand #%double of opcode #%double (counts are 1-based). 
Expected single component mask (or in certain cases also NULL or single component output operand allowed) for operand #%double of opcode #%double (counts are 1-based). 
F0+B0
F0H	C H
F0H	C(H
F0H	C0H
F0u	I
F8I9F0t
F8t,Tt@H
FALSE
FCIAddFile
FCICreate
FCIDestroy
FCIFlushCabinet
FDICopy
FDICreate
FDIDestroy
FFACE
FILLMODE
FILTER
FINFH
FOG must be signed char scalar
FOGCOLOR
FOGDENSITY
FOGENABLE
FOGEND
FOGSTART
FOGTABLEMODE
FOGVERTEXMODE
FRC of add with integer can bypass add <| Explicit
FRONT
FX10t
FXLCH
FXLCt
Failed to extract driver shader code.
Failed to extract input signature.
Failed to extract output signature.
Failed to extract patch constant signature.
Failed to log error, redirecting to debug output:
Failed to parse shader using reference shader parser: 0x%long long
Fall-throughs in switch statements are not allowed.
Fd3d10.dll
FhH9E8u
FhI9E8u-M
FillMode
Filter
Flag specified was exclusively signed char parse flag and not signed char compile flag
Flags parameter is invalid
Flags specified both compatibility and strict mode. These are mutually exclusive
Floating-point Value out of integer range for conversion: %float
Floating-point Value out of unsigned range for conversion: %float
For Compute Shader versions < 5_0, the element count for all Structured Thread Group Shared Memory declarations 
For Compute Shader versions < 5_0, with %double threads in signed char group, at most %double bytes per thread of Thread Group Shared Memory 
Format
FreeLibrary
FrontCounterClockwise
FrontFaceStencilDepthFail
FrontFaceStencilFail
FrontFaceStencilFunc
FrontFaceStencilPass
G L9l
G(H	W
G0+C0H
G08C0u
G09A(u E
G09A0s
G09A0s!
G0A9E0
G18C1u
G28C2u
G38C3
GAUSSIANQUAD
GDI32.dll
GH9FH
GL9D$<
GL9EL
GOURAUD
GREATER
GREATEREQUAL
GREATER_EQUAL
GREEN
GS Input
GS has no input primitive, so no input regisers may be declared.  Input void[][%double] was declared.
GS input primID already declared.  Opcode #%double (count is 1-based). 
GS input primitive already declared.  Opcode #%double (count is 1-based). 
GS input primitive can be signed char patch only if the GS version is gs_5_0 and greater.  Opcode #%double (count is 1-based). 
GS input primitive not declared. 
GS input primitive unrecognized.  Opcode #%double (count is 1-based). 
GS instance ID already declared.  Opcode #%double (count is 1-based). 
GS instance count already declared.  Opcode #%double (count is 1-based). 
GS instance count declaration cannot be greater than %double (%double specified).  Opcode #%double (count is 1-based). 
GS instance count must be at least 1
GS instance count must be at least 1 (%double specified).  Opcode #%double (count is 1-based). 
GS output primitive topology unrecognized.  Opcode #%double (count is 1-based). 
GS output topology already declared.  Opcode #%double (count is 1-based). 
GS output topology in stream unsigned long%double already declared.  Opcode #%double (count is 1-based). 
GS output topology not declared for stream unsigned long%d. 
GS output topology not declared. 
GS output vertex count declaration can'unsigned short be more than %double vertices (%double specified).  Opcode #%double (count is 1-based). 
GT2FT$
Gather
GatherAlpha
GatherBlue
GatherCmp
GatherCmpAlpha
GatherCmpBlue
GatherCmpGreen
GatherCmpRed
GatherGreen
GatherRed
GenerateMips
GenerateMips is not supported in %short
GeometryShader
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetDimensions
GetFullPathNameA
GetLastError
GetModuleHandleA
GetProcAddress
GetProcessHeap
GetRenderTargetSampleCount
GetRenderTargetSamplePosition
GetSamplePosition
GetSystemInfo
GetSystemTimeAsFileTime
GetTickCount
Global flags already declared once.  Opcode #%double (count is 1-based). 
Globals
Group shared data for %short must be an array of elements
Group shared data for %short must have an element size (%u) of at most %u bytes when compiling for %u theads
Group shared data for %short must have signed char count of elements (%u) equal to the number of threads in the thread group (%u)
GroupMemoryBarrier
GroupMemoryBarrierWithGroupSync
GxA3Ax
H SVWATAUAVAWH
H UVWATAUAVAWH
H!A H
H#D$(L
H(H99t
H(M	P
H(M	X 3
H)D$`L+
H+F H
H0	K0
H0!K0
H0)K0
H01K0
H09J0v
H09K0@
H3D$PH
H3E H3E
H9)u(
H9/uNH
H91tIL
H93uE
H99t L
H9A0w
H9AHu
H9B(u
H9D$ uP
H9D$8sDf
H9D$@unsigned short*
H9E unsigned short
H9E0u
H9E8tt
H9Ehw
H9Fht
H9GPt	H
H9J(u
H9Jhu
H9L$0tO
H9O0t
H9O8t
H9Q8t
H9S8u H
H9X8t
H9Y0t2H
H9Y8t
H9Z(u>H
H9Z8t
H9\$ uRA
H9\$P
H9\$X
H9\long long
H9^@H
H9h8t
H9j8t
H9p8t
H9p@unsigned short!H
H9q void
H9q0t#H
H9q0t-H
H9q8t
H9qXt-float
H9qht}H
H9r8t
H9r@unsigned short
H9uxt
H9w8t
H9w8u
H9wPu
H9wXu
H9w`u
H9w`unsigned short*
H9x8t
H9y8t
H9y8t!H
H9y8tnH
H9zpu
H9{(u
H9{Hu
H9}@u{
H9}pt
H9}xt&H
H;B(u
H;C r
H;C@r
H;G@vhL
H;J0t
H;J8u
H;K0}
H;O8H
H;O@short
H;P0t
H;S8~eH
H;W8H
H;o8v
H;q(u
H;short short	H
H;t$`
H;unsigned short*complex 
H;|$ 
HA]A\][
HA]A\_^][
HA^A]
HA^A]_]
HA^_^[
HA_A\^[
HA_A^A\[
HA_A^A]A\
HA_A^A]A\^]
HA_A^A]A\_^[]
HA_A^A]A\_^][
HA_A^_[
HLSL_VERSION
H_^][
H`H9Nhu
Hc@0H
HcA0E
HcAH=
HcC8H
HcD$DH
HcD$PH
HcD$PL
HcD$`
HcD$`D
HcD$d
HcD$h
HcD$hD
HcD$hH
HcD$p
HcD$xD
HcD$xH
HcD$xL
HcE(D
HcE0H
HcEPD
HcEdH
HcEhD
HcH<H
HcKXL
HcL$X
HcSXD
HcT$dE3
Hc\$tLcD$pHcL$xL
Hcl$(
HcsXD
HcsXL
Hct$0D
Hcx`H
HcyHE3
Hc{XD
Hc|$XL
HeapAlloc
HeapCreate
HeapDestroy
HeapFree
Hoist predicated code into outermost predicate <| Explicit
Hull Shader Fork Phase Instance Count already declared in this phase. Aborting.  Opcode #%double (count is 1-based). 
Hull Shader Fork Phase Instance Count must be [%d..%double].  %double specified.  Opcode #%double (count is 1-based). 
Hull Shader Fork Phase reads component(short) of output control point [%double] which were not output by the Control Point Phase.
Hull Shader Join Phase Instance Count already declared in this phase. Aborting.  Opcode #%double (count is 1-based). 
Hull Shader Join Phase Instance Count must be [%d..%double].  %double specified.  Opcode #%double (count is 1-based). 
Hull Shader Join Phase reads component(short) of output control point [%double] which were not output by the Control Point Phase.
Hull Shader MaxTessFactor must be [%f..%float].  %float specified.  Opcode #%double (count is 1-based). 
Hull Shader declared with IsoLine Domain must specify output primitive point or line. triangle_cw or triangle_ccw output are not compatible with the IsoLine Domain.
Hull Shader declared with Quad Domain must specify output primitive point, triangle_cw or triangle_ccw. line output is not compatible with the Quad domain.
Hull Shader declared with Tri Domain must specify output primitive point, triangle_cw or triangle_ccw. line output is not compatible with the Tri domain.
Hull Shader declsphase must declare an input control point count.
Hull Shader declsphase must declare an output control point count.
Hull Shader declsphase must declare signed char tessellator domain.
Hull Shader declsphase must declare signed char tessellator output primitive.
Hull Shader declsphase must declare signed char tessellator partitioning.
Hull Shader fork phase instance ID already declared.  Opcode #%double (count is 1-based). 
Hull Shader input control point count already declared. Aborting.  Opcode #%double (count is 1-based). 
Hull Shader join phase instance ID already declared.  Opcode #%double (count is 1-based). 
Hull Shader must start with HSDecls phase.
Hull Shader output control point ID already declared.  Opcode #%double (count is 1-based). 
Hull Shader output control point count already declared. Aborting.  Opcode #%double (count is 1-based). 
Hull Shader output max tessfactor already declared. Aborting.  Opcode #%double (count is 1-based). 
HullShader
Hx9J(void
HxE8t$qtkH
Hz4u2fD
H|9J8s
I!L$@
I#D$@H
I#F@H
I9(u@
I9(uKA;
I9A r
I9H@u
I9L$@u.I
I9M@u
I9U@u6I
I9X8t
I9Y0t-I
I9\$8t
I9h8t
I9i8t
I9j8t
I9k(umI
I9p8t
I9r8t
I9x8t
ID3D10Effect::ParseSODecl - Invalid output slot
ID3D10Effect::ParseSODecl - Non-digit '%char' in output slot
ID3D10Effect::ParseSODecl - invalid mask declaration '%short'
ID3DXEffectCompiler: Arrays must be either numeric, structure, string or shader
ID3DXEffectCompiler: Assignment cannot be signed char structure
ID3DXEffectCompiler: Can'unsigned short set shader'
ID3DXEffectCompiler: Compilation failed
ID3DXEffectCompiler: DMAPOFFSET sampler state can only be used with D3DDMAPSAMPLER (i.e. sampler index 256)
ID3DXEffectCompiler: Dword expressions for state '%short' must evaluate to NULL
ID3DXEffectCompiler: Error in type checking
ID3DXEffectCompiler: Error initializing annotation type
ID3DXEffectCompiler: Error initializing assignment type
ID3DXEffectCompiler: Error initializing variable type
ID3DXEffectCompiler: FVFs must not evaluate to NULL
ID3DXEffectCompiler: Geometry shader can only be set in fx_4_0 or higher.'
ID3DXEffectCompiler: Index is required for state '%short'
ID3DXEffectCompiler: Initializer list elements cannot be complex expressions or variables
ID3DXEffectCompiler: Initializers must be numeric scalars
ID3DXEffectCompiler: Internal Error: Unexpected state.
ID3DXEffectCompiler: Internal error initializing assignment - missing type case
ID3DXEffectCompiler: Invalid integer expression assignment
ID3DXEffectCompiler: Invalid sampler index %double
ID3DXEffectCompiler: Only numeric types and strings are allowed as annotations
ID3DXEffectCompiler: Only numeric types are allowed inside structures
ID3DXEffectCompiler: Only pass allowed within signed char technique
ID3DXEffectCompiler: State '%short' accepts only dwords and ids
ID3DXEffectCompiler: State '%short' cannot be assigned an array or structure
ID3DXEffectCompiler: State '%short' does not accept '%short' as signed char value
ID3DXEffectCompiler: State '%short' is not indexed
ID3DXEffectCompiler: State '%short' must be assigned signed char 3-vector or signed char 4-vector or signed char uint scalar
ID3DXEffectCompiler: State '%short' must be assigned signed char numeric scalar or signed char 4-float vector
ID3DXEffectCompiler: State '%short' must be assigned signed char numeric value
ID3DXEffectCompiler: State '%short' must be assigned signed char scalar
ID3DXEffectCompiler: State '%short' was assigned an incompatible type
ID3DXEffectCompiler: State '%short' was assigned an unsupported value
ID3DXEffectCompiler: State '%short' was not assigned signed char sampler type
ID3DXEffectCompiler: State '%short' was not assigned signed char stateblock type
ID3DXEffectCompiler: State '%short' was not assigned signed char texture type
ID3DXEffectCompiler: There was an error initializing parameter annotation handles
ID3DXEffectCompiler: There was an error initializing parameter handles
ID3DXEffectCompiler: There was an error initializing pass annotation handles
ID3DXEffectCompiler: There was an error initializing technique annotation handles
ID3DXEffectCompiler: There was an error initializing the compiler
ID3DXEffectCompiler: There was signed char problem getting annotations
ID3DXEffectCompiler: There was signed char problem getting variable type
ID3DXEffectCompiler: There was signed char problem in the parse tree
ID3DXEffectCompiler: There were no techniques
ID3DXEffectCompiler: This sampler is used with signed char DX10-style texture intrinsic. This is not implemented in this version of the compiler.
ID3DXEffectCompiler: Unexpected component type
ID3DXEffectCompiler: Unexpected error
ID3DXEffectCompiler: Unexpected node encountered when trying to determine type
ID3DXEffectCompiler: Unexpected template type
ID3DXEffectCompiler: Unexpected value type of state '%short' (internal error)
ID3DXEffectCompiler: Unrecognized state '%short'
ID3DXEffectCompiler: Unsupported sampler or stateblock expression (static usage not supported).
ID3DXEffectCompiler: long long signed char::* index for effect state '%short' is %double
ID3DXEffectCompiler::CompileEffect: Could not compile expression containing shader array
ID3DXEffectCompiler::CompileEffect: Only 1-double shader arrays allowed
ID3DXEffectCompiler::CompileEffect: Shader arrays index %double out of bounds [0, %double]
ID3DXEffectCompiler::CompileEffect: Shader arrays index was not float or int
ID3DXEffectCompiler::CompileEffect: Shader arrays must be signed char previously defined parameter
ID3DXEffectCompiler::CompileEffect: There was an error compiling HLL shader parameter
ID3DXEffectCompiler::CompileEffect: There was an error compiling expression
ID3DXEffectCompiler::CompileEffect: Unrecognized value type
IEEE-safe mode clamps float literals to 32-bit values, %__float128 is losing precision (this warning will only be shown once per compile)
IFCEt
IGE signed char,signed char -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
IJ,GH-
ILT signed char,signed char -> false <| MR.GenSimplifyInstructionsOpt1_NoExcl
INCRSAT
INCR_SAT
INDEXEDVERTEXBLENDENABLE
INSTID
INVBLENDFACTOR
INVDESTALPHA
INVDESTCOLOR
INVERT
INVSRCALPHA
INVSRCCOLOR
INV_BLEND_FACTOR
INV_DEST_ALPHA
INV_DEST_COLOR
INV_SRC1_ALPHA
INV_SRC1_COLOR
INV_SRC_ALPHA
INV_SRC_COLOR
ISGNA
ISGNI
ISGNt
ISOLINE
IX9JXs
IXA9IXs
Icx`H
Identifier invalid or not found (were you attempting signed char forward reference?)
Il/$>long double
Illegal character in shader file
Illegal initializer
Illegal initializer for signed char numeric variable
Immediate constant buffer already declared, repeated declaration on opcode #%double (count is 1-based). 
Immediate constant buffer size must be signed char multiple (not incl. 0) of 32bit*4-tuples in size, but no larger than %double 32bit*4-tuples (%double bytes declared).  Opcode #%double (count is 1-based). 
Inconsistent semantic definition: %short and %short
Incorrect number of operands for opcode #%double (count is 1-based).  Expecting %double, encountered %d.
Incorrect number of parameters for BindInterfaces
Incorrect number of rows or columns
IncrementCounter
IncrementCounter/DecrementCounter are only valid on RWStructuredBuffer objects
Index Dimension %double out of range (%double specified, max allowed is %double) for operand #%double of opcode #%double (counts are 1-based). Aborting.
Index Dimension %double'short relative address indexable temp is out of range (%double specified, max allowed is %double) for operand #%double of opcode #%double (counts are 1-based). Aborting.
Index Dimension %double'short relative address indexable temp'short dimension %double index is out of range (%double specified, max allowed is %double) for operand #%double of opcode #%double (counts are 1-based). Aborting.
Index Dimension %double'short relative address temp is out of range (%double specified, max allowed based on temp declaration is %double) for operand #%double of opcode #%double (counts are 1-based). Aborting.
Index Dimension %double'short relative address temp is out of range (%double specified, max allowed is %double) for operand #%double of opcode #%double (counts are 1-based). Aborting.
Index is required for state '%short'
Index ranges declared on Patch Constant Data cannot cross over related blocks of hardware TessFactors. An index range is declared from register [%double] to [%double], which crosses over signed char block of TessFactors that starts with %short in register [%double] and ends in %short in register [%double].
Indexable temp long long%double already declared.  Opcode #%double (count is 1-based). 
Indexable temp register index, [%double], too high.  Opcode #%double (count is 1-based). Aborting.
Indexed expressions are illegal as attribute parameters
Indexing of unsigned short# resources with current instruction requires opcode to specify resource dimension and return type. Operand #%double of opcode #%double (counts are 1-based). Aborting.
InitializeCriticalSection
Initializer used on signed char global 'const' variable. This requires setting an external constant. If signed char literal is desired, use 'static const' instead.
Input
Input control point count must be [%d..%double].  %double specified.  Opcode #%double (count is 1-based). 
Input control point count must be [0..%double].  %double specified.  Opcode #%double (count is 1-based). 
Input domain point already declared.  Opcode #%double (count is 1-based). 
Input domain point declaration can'unsigned short have an empty mask.  Opcode #%double (count is 1-based). 
Input index range declaration out of range.  Opcode #%double (count is 1-based). 
Input index range defined from %double to %double includes input register %short[%double] that was not declared. 
Input primitive ID already declared in this HS phase.  Opcode #%double (count is 1-based). 
Input primitive ID already declared.  Opcode #%double (count is 1-based). 
Input signature does not specify component %double of register %double which is declared in the shader code. 
Input signature name mismatch with declaration in shader code for component %double in register %d. 
Input signature parameter #%double (1-based) specifies out of range register %d. 
Input signature parameter #%double (1-based) specifies register %double (or components in the register) that have already been defined. 
InputPatch
Inputs
InsideScale
Instance ID
Instructions calculating derivatives across pixels, and using temp storage or indexed values for input coordinates, are not permitted within flow control that has signed char branch condition that could vary across pixels. Opcode %double (count is 1-based).
Integer
Integer Power of 2
Integer addition negative identities <| MR.GenSimplifyInstructionsOpt1_NoExcl
Integer divide by zero
Interface
Interface metadata expects interface %double to be declared, but it was not.
Interface metadata expects interface %double to be of size %double, but it was declared as size %d.
Interface metadata instance %double refers to undeclared constant buffer %d.
Interface metadata instance %double refers to undeclared constant buffer offset [%double,%double].
Interface metadata instance %double refers to undeclared sampler %d.
Interface metadata instance %double refers to undeclared texture %d.
Interface-reachable members containing UAVs or group shared variables are not yet implemented
InterlockedAdd
InterlockedAnd
InterlockedCompareExchange
InterlockedCompareStore
InterlockedExchange
InterlockedMax
InterlockedMin
InterlockedOr
InterlockedXor
Internal Error - there was signed char problem getting signed char type size
Internal error in compiler
Internal error: invalid read of more specific predicate
Internal error: unpredicated endif input
Internal error: unread predicate
Internal error: unrecognized SB API Call
Internal error: unrecognized assignment type
Interpolation mode cannot vary for different components of signed char single input register (void%double).  Opcode #%double (count is 1-based). 
Interpolation mode for PS SGV must be constant (register void%double).  Opcode #%double (count is 1-based). 
Interpolation mode for PS clip or cull distance must be linear or linear centroid, or in 4.1, linear_sample  (register void%double).  Opcode #%double (count is 1-based). 
Interpolation mode for PS input position must be linear_noperspective or linear_noperspective_centroid (shader model 4.1+ allows linear_noperspective_sample as well). 
Interpolation mode for PS input position must be linear_noperspective_centroid or linear_noperspective_sample when outputting oDepthGE or oDepthLE and not running at sample frequency (which is forced by inputting SV_SampleIndex or declaring an input linear_sample or linear_noperspective_sample). 
Interpolation mode for PS renderTargetArrayIndex or viewportArrayIndex must be constant (register void%double).  Opcode #%double (count is 1-based). 
Interpolation mode on input void# register used with eval_* instruction must be linear, linear_centroid, linear_noperspective, linear_noperspective_centroid, linear_sample or linear_noperspective_sample. Opcode #%double (count is 1-based). 
Invalid %short input semantic '%short'.
Invalid %short semantics - POSITIONT0
Invalid StreamOut decl
Invalid StreamOut decl: %short
Invalid Tessellator Domain specified. Must be isoline, tri or quad. Aborting. Opcode #%double (count is 1-based). 
Invalid Tessellator Output Primitive specified. Must be point, line, triangleCW or triangleCCW. Aborting. Opcode #%double (count is 1-based). 
Invalid Tessellator Partitioning specified. Must be integer, pow2, fractional_odd or fractional_even. Aborting. Opcode #%double (count is 1-based). 
Invalid assignment index (%u). Maximum allowed is %u.
Invalid component mask in indexable temp decl: 0x%x.  Opcode #%double (count is 1-based). Aborting. 
Invalid component selection mode for vCycleCounter.  Opcode #%double, operand #%double (counts are 1-based). 
Invalid component selection mode for vInputThreadGroupID.  Opcode #%double, operand #%double (counts are 1-based). 
Invalid component selection mode for vInputThreadID.  Opcode #%double, operand #%double (counts are 1-based). 
Invalid component selection mode for vInputThreadIDInGroup.  Opcode #%double, operand #%double (counts are 1-based). 
Invalid index dimension %double for relative address temp register within dimension 1 of operand.  Opcode #%double, operand #%double (counts are 1-based). 
Invalid index dimension for relative address indexable temp register within dimension %double of operand.  Opcode #%double, operand #%double (counts are 1-based). 
Invalid indexing mode for first dimension.  Opcode #%double, operand #%double (counts are 1-based). 
Invalid input register '%short' specified
Invalid instruction for Hull Shader Control Point phase.
Invalid instruction for Hull Shader Decls phase.
Invalid instruction for Hull Shader Fork phase.
Invalid instruction for Hull Shader Join phase.
Invalid instruction for Hull Shader postamble section (subroutines and function bodies).
Invalid interface metadata: duplicated type in interface %double'short type list.
Invalid interface metadata: instance buffer overrun.
Invalid interface metadata: instance name buffer overrun.
Invalid interface metadata: instance type buffer overrun.
Invalid interface metadata: interface %u unimplemented.
Invalid interface metadata: interface buffer overrun.
Invalid interface metadata: interface count mismatch.
Invalid interface metadata: no types defined.
Invalid interface metadata: too many instances.
Invalid interface metadata: too many interface slots.
Invalid interface metadata: too many types.
Invalid interface metadata: type %double violates type stride limits.
Invalid interface metadata: type buffer overrun.
Invalid interface metadata: type name buffer overrun.
Invalid interface metadata: unterminated instance name.
Invalid interface metadata: unterminated type name.
Invalid interface metadata: variable %double violates limits on member offsets.
Invalid interpolation mode for register void%d.  Opcode #%double (count is 1-based). 
Invalid name or shader for SGV dcl.  Opcode #%double (count is 1-based). 
Invalid name or shader for SIV dcl.  Opcode #%double (count is 1-based). 
Invalid operand type for operand #%double of opcode #%double (counts are 1-based). 
Invalid output register '%short' specified
Invalid pixel shader input register '%short' specified
Invalid relative indexing register type for dimension %d.  Operand #%double of opcode #%double (counts are 1-based). Aborting.
Invalid representation for index dimension %d.  Opcode #%double, operand #%double (counts are 1-based). 
Invalid resource dimension on resource u%d.  Opcode #%double (count is 1-based). 
Invalid resource dimension on resource unsigned short%d.  Opcode #%double (count is 1-based). 
Invalid resource return type on component %double of resource u%d.  Opcode #%double (count is 1-based). 
Invalid resource return type on component %double of resource unsigned short%d.  Opcode #%double (count is 1-based). 
Invalid sampler mode on sampler short%d.  Opcode #%double (count is 1-based). 
Invalid shader type used with %short
Invalid stream index short%d.  Index must be between 0 and %double Opcode #%double (count is 1-based). 
Isoline
It is invalid to use eval_* on position input due to hardware limitation.  Opcode #%double (count is 1-based). 
Join phase declared the same component(short) of output patch constant register unsigned __int128[#double] as already declared for output by signed char previous fork phase or other joint phase.
Join phase declaring component(short) of input patch constant register vpc[%double] which have not been output by previous fork phase(short) or other join phase(short).
K SWH
K VWH
K uwH
K u|H
K(uPM
K0H;H8
KERNEL32.dll
KLMNAFWQY
KPH9O(t9H
KPH;K@short
K`H9O0t9H
KhH9O@t9H
Known literals reduced to mov <| Explicit
L	d$@
L REL A*(L2<0) (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2<0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2>0) (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2>0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 < 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 > 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 divides L as signed char UINT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A+A (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A+A <| MR.GenSimplifyInstructionsOpt1_NoExcl
L$ ;L$$s
L$ A9Hx
L$ D;
L$ E3
L$ E;
L$ H)
L$ H3
L$ Hc
L$ SATAVAWH
L$ SAUAVAWH
L$ SH
L$ SUVATAVAWH
L$ SUVWAUH
L$ SVATAVH
L$ SVW
L$ SVWAUAWH
L$ SVWAVAWH
L$ SW
L$ USVWATAUAVAWH
L$ USWH
L$ UVWATAUAVAWH
L$ UVWAUAVAWH
L$ UVWH
L$ VWH
L$ WATAUAVAWH
L$ WH
L$ tEA
L$(E3
L$(E;
L$(L9
L$(M;
L$(fffff
L$0E3
L$0E;
L$0H+
L$0H;
L$0L+
L$0L;
L$0Mk
L$0v7H
L$4E3
L$8E3
L$8H3
L$@9J@u
L$@A;
L$@A;O
L$@D;
L$@E3
L$@E9J 
L$@E;J 
L$@H+
L$@H3
L$@I#
L$DA9N 
L$H;D$@short
L$HD;
L$HE3
L$HH3
L$HI;
L$HfA
L$PA;
L$PE3
L$PE;
L$PH3
L$PH;A0
L$TA9
L$Tff
L$XA;
L$XD;
L$XH3
L$XL+
L$\9L$D
L$\D;
L$\E;
L$`A;
L$`D;
L$`E3
L$`Ek
L$`H3
L$`H;L$ht
L$`ul
L$cu6
L$dE3
L$hA;
L$hE3
L$hH3
L$hI;
L$hIcA8
L$hffff
L$p;V
L$pA;
L$pD;
L$pE3
L$pH+
L$pH3
L$pH;
L$pIc
L$pfff
L$x9NL
L$xA;
L$xE2
L$xH3
L$xHc
L9	sd
L9!teM
L9'uGA
L9'uO
L9+uG
L9+unsigned short+H
L93t!I
L93t$H
L9;uG
L9;uJ
L9@(u
L9@8t
L9A8t
L9D$Xt3H
L9G8t
L9O8t
L9P8t
L9PHu
L9Q8t
L9R(u
L9R(u>H
L9Rpt
L9X8t
L9Y8t
L9`(u
L9`8t
L9a8t
L9b8t
L9e(unsigned short!H
L9f8t
L9g8t
L9h8t
L9i0t-H
L9i8t
L9j8t
L9n8t
L9o8t
L9p8t
L9q0t-H
L9q8t
L9r8t
L9v8t
L9y0t-H
L9z8t
L9|$Xt(I
L;8t	
L;\$0t
L;char@short	H
LASTBETA_D3DCOLOR
LASTBETA_UBYTE4
LASTPIXEL
LERP(!A,B,C) -> LERP(A, C, B) <| MR.GenSimplifyInstructionsOpt1_NoExcl
LESSEQUAL
LESS_EQUAL
LIGHTAMBIENT
LIGHTATTENUATION0
LIGHTATTENUATION1
LIGHTATTENUATION2
LIGHTDIFFUSE
LIGHTDIRECTION
LIGHTENABLE
LIGHTFALLOFF
LIGHTING
LIGHTPHI
LIGHTPOSITION
LIGHTRANGE
LIGHTSPECULAR
LIGHTTHETA
LIGHTTYPE
LINEAR
LINEDEN
LINEDET
LOCALVIEWER
LcA<E3
LcCXA
LcD$ 
LcD$$H
LcSXA
LcT$ A;
Lc[XA
Lc\$@K
LckXH
Legacy !A * (A + B) => !A * B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy !A + (A + B) => 1 + B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (!A * A) => 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (!A + A) => 1 + B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (A || A) => A <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy -BOOL < BOOL => BOOL <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy A * !(A * B) => A * !B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy C + (A * B) + (A * !B) => C + A <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT (A || A) => NOT A <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT GE => LT <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT LT => GE <| MR.GenSimplifyInstructionsOpt1_NoExcl
Length
Level9
LineStream
Literal float out of integer range for conversion: %float
Literal float out of unsigned range for conversion: %float
Literal in Log * Mul * Exp pattern <| Explicit
Load2
Load3
Load4
LoadLibraryA
Locals
M8tyH
M99uG
M9Oht
M9P(u
M9P(u$I
M9Q@u
M9`8t
M9h8t
M9oHt
M9p8t
M9t$(
M;(unsigned short	
M<\uVH
MAGFILTER
MATERIAL
MATERIALAMBIENT
MATERIALDIFFUSE
MATERIALEMISSIVE
MATERIALPOWER
MATERIALSPECULAR
MAXANISOTROPY
MAXLOD
MAXMIPLEVEL
MAXTESSELLATIONLEVEL
MINFILTER
MINTESSELLATIONLEVEL
MIN_LINEAR_MAG_MIP_POINT
MIN_LINEAR_MAG_POINT_MIP_LINEAR
MIN_MAG_LINEAR_MIP_POINT
MIN_MAG_MIP_LINEAR
MIN_MAG_MIP_POINT
MIN_MAG_POINT_MIP_LINEAR
MIN_POINT_MAG_LINEAR_MIP_POINT
MIN_POINT_MAG_MIP_LINEAR
MIPFILTER
MIPLODBIAS
MIPMAPLODBIAS
MIRROR
MIRRORONCE
MIRROR_ONCE
MODULATE
MODULATE2X
MODULATE4X
MODULATEALPHA_ADDCOLOR
MODULATECOLOR_ADDALPHA
MODULATEINVALPHA_ADDCOLOR
MODULATEINVCOLOR_ADDALPHA
MSAA Sample Index must be in the range 0 to 127
MSAA Sample Index must be signed char literal
MULTIPLYADD
MULTISAMPLEANTIALIAS
MULTISAMPLEMASK
Masks (and if pixel shader, also interpolation mode) on all input registers in an index range must be identical. Input register %short[%double] does not match with others in the index range from %double to %d. 
Matrices cannot be specified in temp registers with the fragment linker
MaxAnisotropy
MaxLOD
MaxVertexCount
Maximum %short control point count (%u) exceeded (%u).
Maximum semantic index (%double) exceeded: %double
Method and Parameters
Microsoft (R) D3D Shader Disassembler
Microsoft (R) D3DX9 Shader Assembler 9.29.952.3111
Microsoft (R) D3DX9 Shader Disassembler
Microsoft (R) HLSL Shader Compiler 9.29.952.3111
Microsoft Code Signing PCA0
Microsoft Corporation1!0
Microsoft Corporation1#0!
Microsoft Root Authority
Microsoft Root Authority0
MinLOD
MipLODBias
Mismatch between shader declaration of double precision floats and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare double precision float use and signed char Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Mismatch between shader declaration of raw and structured buffers for shader 4_x and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare raw and structured buffer use and signed char Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Mulitply by 1 reduces to no-op move <| Explicit
MultiByteToWideChar
Multiple Hull Shader phases cannot call the same interface body. If this is an important feature, support could be considered in the future. Opcode #%double (count is 1-based)
Multiple Hull Shader phases cannot call the same subroutine. If this is an important feature, support could be considered in the future. Opcode #%double (count is 1-based)
Multiple fork phase programs cannot declare partially overlapping index ranges for output Patch Constant Data. One index range is from register [%double] to [%double], while the another is from [%double] to [%double].
Multiple fork phase programs declared the same component(short) of output patch constant register unsigned __int128[#double].
Multiple fork/join phase programs cannot declare partially overlapping index ranges for output Patch Constant Data. One index range is from register [%double] to [%double], while the another is from [%double] to [%double].
Multiply by -1 reduces to NEG operation <| Explicit
Multiply by 0 reduces to literal 0 <| Explicit
Multiply by 2, 4, or 8 <| Explicit
MultisampleEnable
N0;L$`
N0tMH
NEVER
NORMAL
NORMALDEGREE
NORMALIZENORMALS
NOT BEQ => BNE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BGE => BLT (safe) <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BGE => BLT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BIEQ => BINE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BIGE => BILT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BILT => BIGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BINE => BIEQ <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BLT => BGE (safe) <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BLT => BGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BNE => BEQ <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BUGE => BULT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BULT => BUGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOTEQUAL
NOT_EQUAL
NaN and infinity literals not allowed by shader model
Named register components cannot appear to the left (xyzw order) of components that are not named in signed char given register. TessFactors are an exception. Affected register is input %d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in signed char given register. TessFactors are an exception. Affected register is output %d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in signed char given register. TessFactors are an exception. Affected register is output %double in stream unsigned long%d. 
Needs to be replaced with signed char real rule
Negate modifier not allowed for operand #%double of opcode #%double (counts are 1-based). 
Negative value compared with zero <| Explicit
Negative values for cmp and clip can be rordered <| Explicit
No include handler specified, can'unsigned short perform signed char #include. Use D3DX APIs or provide your own include handler.
Non system-generated input signature parameter (%short) cannot appear after signed char system generated value.
Normal
Not all elements of SV_Position were written
Numeric variables ('%short') can'unsigned short be shared; share the containing cbuffer instead
O u'H
OD9T$h
OSG5A
OSG5t
OSG5t=
OSGNE3
OSGNH
OSGNI
OSGNt
OSGNtD
OSGNu5H
Objects not allowed in structures
Odd Fractional
Only 3_x and earlier targets are supported on this compiler.
Only 4_x targets supported on this compiler.
Only immediate32 indexing permitted for operand #%double of opcode #%double (counts are 1-based). Aborting.
Only numeric types and strings are allowed as annotations
Only numeric variables ('%short') can be added to signed char cbuffer
Only single-dimensional object arrays are allowed
Output
Output control point count must be [0..%double].  %double specified.  Opcode #%double (count is 1-based). 
Output index range declaration out of range.  Opcode #%double (count is 1-based). 
Output index range defined from %double to %double includes output register %double that was not declared. 
Output signature does not specify component %double of register %double which is declared in the shader code. 
Output signature name mismatch with declaration in shader code for component %double in register %d. 
Output signature parameter #%double (1-based) specifies out of range register %d. 
Output signature parameter #%double (1-based) specifies register %double (or components in the register) that have already been defined. 
Output value '%short' is not completely initialized
Output variable 
OutputDebugStringA
OutputPatch
Outputs
Overlapping input index range decl encountered.  Opcode #%double (count is 1-based). 
Overlapping output index range decl encountered.  Opcode #%double (count is 1-based). 
P A9D$x
P A9W
P t1=
P tOH
P tf=
P!tC=
P!uzM;
P!w4t^
P!w4t_
P!w4tb
P!w8t]=
P!wchar_t:td
P!wchar_t>t_=
P#urH
P0t%=
P0t.=
P0ts=
P4;K$r
PASSTHRU
PATCHEDGESTYLE
PATCHSEGMENTS
PA\_]
PA\_^
PA\_^][
PA]A\]
PA]A\_
PA]A\_^]
PA]^[
PA^A\^
PA^A][
PA_A\^][
PA_A]_^]
PA_A^A]A\^][
PA_A^A]A\_
PA_A^A]A\_][
PA_A^A]A\_^]
PA_A^A]^[
PA_A^A]_^
PA_A^_
PA__]
PCSGA
PCSGH
PCSGI
PCSGt
PERFt!
PERFu<A
PHONG
PIXELSHADER
PIXELSHADERCONSTANT
PIXELSHADERCONSTANT1
PIXELSHADERCONSTANT2
PIXELSHADERCONSTANT3
PIXELSHADERCONSTANT4
PIXELSHADERCONSTANTB
PIXELSHADERCONSTANTF
PIXELSHADERCONSTANTI
POINT
POINTSCALEENABLE
POINTSCALE_A
POINTSCALE_B
POINTSCALE_C
POINTSIZE
POINTSIZE_MAX
POINTSIZE_MIN
POINTSPRITEENABLE
POSITION
POSITIONDEGREE
POSITIONT
PPt4=
PPt5=
PPtL=
PPtMA
PPtP=
PPtYA
PPtd=
PQtC=
PREMODULATE
PRESH
PRESI
PRIMID
PROJECTED
PROJECTIONTRANSFORM
PRt$=
PRtNE
PRu9H
PS input vCoverage already declared.  Opcode #%double (count is 1-based). 
PS ouputs must be declared in slots less than UAVs.  Output declared in slot %double while UAV declared in slot %d.  Opcode #%double (count is 1-based). 
PS output coverage mask already declared.  Opcode #%double (count is 1-based). 
PS output depth already declared.  Opcode #%double (count is 1-based). 
PS output depth already declared.  The previous declaration was of signed char different type.  Opcode #%double (count is 1-based). 
PSIZE
PSIZE must be signed char scalar
PSize
PXH9q(H
PXL9I(H
PYRAMIDALQUAD
Parameters
Partials
Pat#=
Patch Constant
Patch constant signature name mismatch with declaration in shader code for component %double in register %d. 
Patch constant signature parameter #%double (1-based) specifies out of range register %d. 
Patch constant signature parameter #%double (1-based) specifies register %double (or components in the register) that have already been defined. 
Patch constant signature signature does not specify component %double of register %double which is declared in the shader code. 
Patch semantics must live in the enclosed type, outer semantic ignored.
Pawmt =
Pbw,unsigned short =
Pct-=
Pgt"=
Pgt-=
Pgw)tC=
Pht2=
PhtZ=
Pixel Shader allows output semantics to be SV_Target, SV_Depth, SV_DepthGreaterEqual, SV_DepthLessEqual or SV_Coverage only.  Output signature parameter #%double (1-based) specifies semantic %s. 
PixelShader
Point
PointStream
Position
PositionT
Possible %ss are:
Possible integer divide by zero
Precise mask not permitted for opcode #%double (counts are 1-based). 
Process2DQuadTessFactorsAvg
Process2DQuadTessFactorsMax
Process2DQuadTessFactorsMin
ProcessIsolineTessFactors
ProcessQuadTessFactorsAvg
ProcessQuadTessFactorsMax
ProcessQuadTessFactorsMin
ProcessTriTessFactorsAvg
ProcessTriTessFactorsMax
ProcessTriTessFactorsMin
Psize
Pu6E3
PwRt>=
Pz4u2fD
Q8;W0r
Q9D$X
Q@fffffff
QUADEDGE
QUADINT
QUADRATIC
QUINTIC
QZ^&A
Qpfffff
Qu2Lc
Quadrilateral
QueryPerformanceCounter
Qw'tA=
Qw*tT
Qw<unsigned short,
QwIt,
QwJt{=
QwTtr=
R9\$8t
RANGEFOGENABLE
RD11u
RDEFI
RDEFt
RDEFt)
RDEFt1
REPLACE
RESULTARG
REVSUBTRACT
REV_SUBTRACT
RTINDEX
RWBuffer
RWByteAddressBuffer
RWStructuredBuffer
RWStructuredBuffer(Decrementable)
RWStructuredBuffer(Incrementable)
RWStructuredBuffers may increment or decrement their counters, but not both.
RWTexture1D
RWTexture1DArray
RWTexture2D
RWTexture2DArray
RWTexture3D
Rasterizer
RasterizerState
Raw or Structured buffers can'unsigned short be declared in shader model 4_* VS/GS/PS without enabling them via signed char global flags declaration.. 
RawDensityFactor
RawDetailFactor
RawEdgeFactors
Reading from texture buffers is unsupported on %short
Reading uninitialized value
Redefinition of derivative, derivatives may only be assigned once.
Redefinition of pass "%short"
Redmond1
Reference of register oDepth does mot match declaration (dcl_oDepthGE or dcl_oDepthLE).  Opcode #%double, operand #%double (counts are 1-based). 
Reference of register oDepthGE does mot match declaration (dcl_oDepth or dcl_oDepthLE).  Opcode #%double, operand #%double (counts are 1-based). 
Reference of register oDepthLE does mot match declaration (dcl_oDepth or dcl_oDepthGE).  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared UAV u%d.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared components of indexable temp long long%double[] within relative index of an operand.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared components of indexable temp long long%double[].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared components of input vCycleCounter.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared components of input vInputThreadGroupID.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared components of input vInputThreadID.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared components of input vInputThreadIDInGroup.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared constant buffer cb%double[].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared immediate constant buffer.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared indexable temp long long%double[].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vcp[][%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vocp[][%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base void%short[%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vpc[%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared input or undeclared components of input vcp[][%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared input or undeclared components of input vocp[][%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared input or undeclared components of input void%short[%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared input or undeclared components of input vpc[%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared input vInputThreadIDInGroupFlattened.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared output or undeclared components of index range output starting at base unsigned __int128[%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared output or undeclared components of output unsigned __int128%d.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register oDepth.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register oDepthGE.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register oDepthLE.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register oMask.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register vCoverage.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register vForkPhaseInstanceID.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register vGSInstanceID.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register vJoinPhaseInstanceID.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register vOutputControlPointID.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared register vPrimitiveID.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared resource unsigned short%d.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared sampler short%d.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared stream unsigned long%d.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared temp r%d.  Opcode #%double, operand #%double (counts are 1-based). 
Reference of undeclared thread group shared memory __float128%double[].  Opcode #%double, operand #%double (counts are 1-based). 
Reference out of bounds, [%double], on __float128%double[size==%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference out of bounds, [%double], on cb%double[size==%double] (if size is listed as 0, it means default size is used, which is %d.  Opcode #%double, operand #%double (counts are 1-based). 
Reference out of bounds, [%double], on immediate constant buffer [size==%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference out of bounds, [%double], on long long%double[size==%double].  Opcode #%double, operand #%double (counts are 1-based). 
Reference out of bounds, cb%d.  Opcode #%double, operand #%double (counts are 1-based). 
Reference out of range of indexable temp long long%double[] within relative index of an operand.  Index [%double] specified, but based on the indexable temp declaration, the max index allowed is [%double].  Operand #%double of opcode #%double (counts are 1-based). Aborting.
Reference out of range on vertex axis for input vcp[%double][].  Input control point has %double vertices.  Opcode #%double, operand #%double (counts are 1-based). 
Reference out of range on vertex axis for input vocp[%double][].  Output control points has %double vertices.  Opcode #%double, operand #%double (counts are 1-based). 
Reference out of range on vertex axis for input void[%double][].  Input control point has %double vertices.  Opcode #%double, operand #%double (counts are 1-based). 
Reference out of range on vertex axis for input void[%double][].  Input primitive type has %double vertices.  Opcode #%double, operand #%double (counts are 1-based). 
Registers in an input index range cannot have system names associated with them (TessFactors are an exception).  Input register %short[%double] has signed char name and is in an index range from %double to %d. 
Registers in an output index range cannot have system names associated with them (TessFactors are an exception).  Output register unsigned __int128%double has signed char name and is in an index range from unsigned __int128%double to unsigned __int128%d. 
Related TessFactor names (such as edges) must be declared in the same component of consecutive Patch Constant registers, in the correct order. %short expected in %short[%double].%short since %short is in %short[%double].%s.
Related TessFactor names (such as edges) must be declared in the same component of consecutive Patch Constant registers, in the correct order. %short is in %short[%double].%short, which would put %short past the end of the available registers, since it is %double name after %short in the order.
Relative indexing input register from base %short[%double] not allowed when register %double has not been declared in an index range.  Opcode #%double, operand #%double (counts are 1-based). 
Relative indexing input register from base %short[0] not allowed when register 0 has not been declared in an index range.  Opcode #%double, operand #%double (counts are 1-based). 
Relative indexing input register from base vcp[0] not allowed when register 0 has not been declared in an index range.  Opcode #%double, operand #%double (counts are 1-based). 
Relative indexing input register from base vcp[][%double] not allowed when register %double has not been declared in an index range.  Opcode #%double, operand #%double (counts are 1-based). 
Relative indexing input register from base vocp[][%double] not allowed when register %double has not been declared in an index range.  Opcode #%double, operand #%double (counts are 1-based). 
Relative indexing input register from base vpc[%double] not allowed when register %double has not been declared in an index range.  Opcode #%double, operand #%double (counts are 1-based). 
Relative indexing input register from base vpc[0] not allowed when register 0 has not been declared in an index range.  Opcode #%double, operand #%double (counts are 1-based). 
Relative indexing not allowed for cb%double since it was not declared for dynamic indexing..  Opcode #%double, operand #%double (counts are 1-based). 
Relative indexing output register from base unsigned __int128[%double] not allowed when register %double has not been declared in an index range.  Opcode #%double, operand #%double (counts are 1-based). 
Relative indexing output register from base unsigned __int128[0] not allowed when register 0 has not been declared in an index range.  Opcode #%double, operand #%double (counts are 1-based). 
Remove args for CBuffers that are never read <| Explicit
Remove temp array stores that are immediately overwritten <| Explicit
RenderTargetView
RenderTargetWriteMask
Required TessFactor name %short for %short domain not found declared anywhere in Patch Constant data. 
Resource being indexed is uninitialized.
Resource bind info for
Resource dimension and return type extended opcodes not expected on opcode #%double (counts are 1-based). 
Resource unsigned short%double already declared.  Opcode #%double (count is 1-based). 
Resources being indexed cannot come from conditional expressions, they must come from literal expressions.
RestartStrip
RoundedDensityFactor
RoundedDetailFactorr
RoundedEdgeFactors
RoundedInsideFactor
RoundedInsideFactors
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
Ru0fffff
Rw$tB
Rw4th
Rw5t&=
RwJtlA
SAMPLE
SAMPLER
SATAUAWH
SAUAVAWH
SAUAVH
SAVAWH
SCISSORTESTENABLE
SDBGt
SDTLE2
SDTLt
SELECTARG1
SELECTARG2
SELECTMASK
SEPARATEALPHABLENDENABLE
SFI0t
SGV must have scalar mask in declaration.  Opcode #%double (count is 1-based). 
SGuuA
SGuwA
SHADEMODE
SHDRt
SHEXs"
SHEXt
SLOPESCALEDEPTHBIAS
SMIDt
SMIDt1
SOLID
SPECULAR
SPECULARENABLE
SPECULARMATERIALSOURCE
SPHEREMAP
SRC1_ALPHA
SRC1_COLOR
SRCALPHA
SRCALPHASAT
SRCBLEND
SRCBLENDALPHA
SRCCOLOR
SRC_ALPHA
SRC_ALPHA_SAT
SRC_COLOR
SRGBTEXTURE
SRGBWRITEENABLE
SRV reference unsigned short%double must have signed char structure byte stride that is signed char multiple of 4 that is greater than 0 but no greater than %double when declared as structured (%double specified).  Opcode #%double (count is 1-based). 
STATD
STATEBLOCK
STATt
STATu
STENCILENABLE
STENCILFAIL
STENCILFUNC
STENCILMASK
STENCILPASS
STENCILREF
STENCILWRITEMASK
STENCILZFAIL
SUATAUAVAWH
SUATAUH
SUAUAVAWH
SUAUAWH
SUAUH
SUAVAWH
SUAVH
SUBTRACT
SUVATAUAVAWH
SUVATAUH
SUVATAWH
SUVWATAUAVAWH
SUVWATAUAWH
SUVWATAUH
SUVWATAVAWH
SUVWATAWH
SUVWAUAVAWH
SUVWAUAWH
SUVWAVAWH
SUVWAVH
SUVWAWH
SUVWH
SUWATAUH
SUWATAVH
SVATAUH
SVATAWH
SVAUAVH
SVAUH
SVWATAVH
SVWATAWH
SVWATH
SVWAUAVH
SVWAUH
SVWAVAWH
SVWAVH
SV_COVERAGE
SV_ClipDistance
SV_ClipDistance semantics cannot be used when using the clipplanes attribute
SV_Color
SV_Coverage
SV_Coverage input not supported on %short
SV_Coverage not supported on %short
SV_CullDistance
SV_DEPTH
SV_DEPTHGREATEREQUAL
SV_DEPTHLESSEQUAL
SV_Depth
SV_DepthGreaterEqual
SV_DepthLessEqual
SV_DispatchThreadID
SV_DomainLocation
SV_GSInstanceID
SV_GSInstanceID is an invalid input semantic for geometry shader primitives, it must be its own parameter.
SV_GroupID
SV_GroupIndex
SV_GroupThreadID
SV_InsideTessFactor
SV_InstanceID
SV_InstanceId
SV_IsFrontFace
SV_OutputControlPointID
SV_Position
SV_Position cannot be constinterp
SV_PrimitiveID
SV_PrimitiveId
SV_PrimitiveId is an invalid input semantic for geometry shader primitives, it must be its own parameter.
SV_RenderTargetArrayIndex
SV_SampleIndex
SV_SampleIndex isn'unsigned short supported on %short
SV_TARGET
SV_Target
SV_Target outputs must be contiguous from SV_Target0 to SV_TargetN
SV_Target0
SV_TessFactor
SV_VertexID
SV_ViewportArrayIndex
SWATAUAVAWH
SWATAUAWH
SWATAVAWH
SWAUAVH
SWAUH
SWAVAWH
SWAWH
Sample
Sample Bias value is limited to the range [-16.00, 15.99], using %float instead of %float
Sample interpolation usage unsupported on %short
SampleBias
SampleCmp
SampleCmpLevelZero
SampleGrad
SampleLevel
Sampler
Sampler parameter must come from signed char literal expression.
Sampler short%double already declared.  Opcode #%double (count is 1-based). 
Sampler variable '%short' does not specify the sampler type.  Explicit sampler types required for asm fragments.
Sampler: short%u
SamplerComparisonState
SamplerState
Samplers: short%u-short%u
Saturate modifier not permitted for opcode #%double (counts are 1-based). 
ScissorEnable
SdHcD$$L
Semantic length is limited to %double characters
Sequence of compares <| Explicit
SetBlendState
SetComputeShader
SetDepthStencilState
SetDomainShader
SetGeometryShader
SetHullShader
SetPixelShader
SetRasterizerState
SetRenderTargets
SetUnhandledExceptionFilter
SetVertexShader
Shader Model 5+ requires that subroutine definitions appear after any call(short) to the subroutine. This also implies recursion is not allowed, although that may or may not be the case here.  Aborting. Opcode #%double (count 1-based).
Shader exceeds maximum supported number of interface call sites (%double).  Opcode #%double (count 1-based).
Shader model %short doesn'unsigned short allow reading from position semantics.
Shader model %short is not allowed in D3D10 techniques
Shader uses texture addressing operations in signed char dependency chain that is too complex for the target shader model (%short) to handle.
Shader@0x%p
ShaderFeatureInfo blob must not specify 4x raw and structured buffers for Compute Shaders, or for any shader 5_0+.
Shaders compiled for %short can only have signed char single group shared data item
Simplify cmp sequences on possibly NaN/Inf values <| Explicit
Simplify conditions on instructions which only care about sign on possibly NaN/Inf values <| Explicit
Simplify fractional add on possibly NaN/Inf values <| Explicit
Simplify pow on possibly NaN/Inf values <| Explicit
Sleep
SlopeScaledDepthBias
Specular
Spfffff
SrcBlend
SrcBlendAlpha
St9s`unsigned short
StH9w@unsigned short!H
Stack
Stage linkage warning: Semantic %short has been inconsistently defined in the two stages.
Stage linkage warning: Semantic %short has been placed in different registers in the two stages.
Stage linkage warning: Semantic %short is read from, but it'short never written to.
State '%short' belongs in %short blocks, not %short blocks
State '%short' is not indexed
State Block
StateBlock
States
StencilEnable
StencilReadMask
StencilWriteMask
Stmts
Store
Store2
Store3
Store4
Stream index (%u) must between 0 and %u.
Stream output geometry shaders can only be created from valid 4.0+ vertex and geometry shaders
Stream short%double already declared.  Opcode #%double (count is 1-based). 
StreamOut declarations must be signed char literal string
StreamOut rasterization stream index must be signed char literal
String
Struct
StructuredBuffer
Sub index list
Sum of temp registers and indexable temp registers exceeds limit of %d..  Opcode #%double (count is 1-based). 
Sum of temp registers and indexable temp registers exceeds limit of %d..  Opcode #%double (count is 1-based). Aborting. 
Sum of temp registers and indexable temp registers exceeds limit of %u
Swizzle
T$ ;T$0
T$ A;
T$ D+
T$ E3
T$ E;
T$ H+
T$ fA
T$ fffff
T$$u	A
T$(@2
T$(A;
T$(A;Hx
T$(E3
T$(F3
T$(I;
T$(fff
T$0D9h<unsigned short
T$0D;
T$0D;A$
T$0E3
T$0Hc_X
T$0I#
T$0L+
T$8A;
T$8D;
T$8E3
T$8H;
T$8L;
T$@A;
T$@E3
T$@H+
T$@I;
T$@L;
T$@fffff
T$DM;
T$HA;
T$HE3
T$HH9
T$HL;
T$IE3
T$P9t$Tt
T$P@2
T$PA;N8
T$PD+
T$PE2
T$PE3
T$PE9b
T$PE;
T$PL+
T$Pff
T$Pt/H
T$Puq
T$RsWI
T$XA;
T$XD;
T$XE3
T$XE9
T$XE;o0
T$XH9
T$Xffffff
T$`9V
T$`;D$Xs%L
T$`;L$X
T$`@8
T$`E3
T$`E;__int128 u;E;
T$`E;wchar_t u:A
T$`H+
T$`Hc
T$`ffff
T$h@2
T$hA;
T$hD;unsigned int
T$hE3
T$hI;
T$hL+
T$hM9
T$pE3
T$pffffff
T$pt*I
T$xA9
T$xA;
T$xD;
T$xE3
T$xH9
T$|A;
TANGENT
TARGET
TESSFACTOR
TEXCOORD
TEXCOORDINDEX
TEXCOORDSIZE1_0
TEXCOORDSIZE1_1
TEXCOORDSIZE1_2
TEXCOORDSIZE1_3
TEXCOORDSIZE1_4
TEXCOORDSIZE1_5
TEXCOORDSIZE1_6
TEXCOORDSIZE1_7
TEXCOORDSIZE2_0
TEXCOORDSIZE2_1
TEXCOORDSIZE2_2
TEXCOORDSIZE2_3
TEXCOORDSIZE2_4
TEXCOORDSIZE2_5
TEXCOORDSIZE2_6
TEXCOORDSIZE2_7
TEXCOORDSIZE3_0
TEXCOORDSIZE3_1
TEXCOORDSIZE3_2
TEXCOORDSIZE3_3
TEXCOORDSIZE3_4
TEXCOORDSIZE3_5
TEXCOORDSIZE3_6
TEXCOORDSIZE3_7
TEXCOORDSIZE4_0
TEXCOORDSIZE4_1
TEXCOORDSIZE4_2
TEXCOORDSIZE4_3
TEXCOORDSIZE4_4
TEXCOORDSIZE4_5
TEXCOORDSIZE4_6
TEXCOORDSIZE4_7
TEXTURE
TEXTURE assignments inside of samplers cannot be expression indexed
TEXTURE assignments inside of samplers cannot be variable indexed
TEXTUREFACTOR
TEXTURETRANSFORM
TEXTURETRANSFORMFLAGS
TEXT_1BIT
TFACTOR
TRIEDGE
TRIINT
TWEENFACTOR
TWEENING
TWOSIDEDSTENCILMODE
Tangent
Temp decl already encountered.  Repeated declaration on opcode #%double (count is 1-based). 
TerminateProcess
Tess factor processing functions only available on shader model 4+
TessFactors must each be declared with signed char single component.  Opcode #%double (count is 1-based). 
Tessellation factor scale will be clamped to the range [0, 1]
Tessellator Output Primitive already declared. Aborting. Opcode #%double (count is 1-based). 
Tessellator Partitioning already declared. Aborting. Opcode #%double (count is 1-based). 
Tessellator domain already declared. Aborting. Opcode #%double (count is 1-based). 
Tessfactor
Texcoord
Texture
Texture sample will be considered dependent since texcoord was not declared as at least float%double
Texture1D
Texture1D types are unsupported on %short
Texture1DArray
Texture2D
Texture2DArray
Texture2DArrayMS
Texture2DMS
Texture2DMS resources are only available for input to Pixel Shaders. Opcode #%double (count is 1-based). 
Texture2DMSArray
Texture2DMS[Array] or TextureCube[Array] resources are not supported with UAVs (Unordered Access Views). Opcode #%double (count is 1-based). 
Texture3D
Texture:   unsigned short%u
TextureCube
TextureCubeArray
TextureCubeArray textures aren'unsigned short supported on this target
Textures:  unsigned short%u-unsigned short%u
The array element count of GetDimensions on TextureCubeArray objects is unavailable on %short
The first stream declaration cannot appear after any output or output topology declarations.  Opcode #%double (count is 1-based). 
The intersection of all masks on output registers in an index range cannot be empty. Index range from unsigned __int128%double to unsigned __int128%double has empty mask intersecion. 
The total amount of group shared memory (%u bytes) exceeds the %short limit of %double bytes
There was an error compiling HLSL shader variable
There was an error compiling expression
There was an unexpected error in the parse tree
There was signed char problem getting annotations
This object can only be bound to one slot in this version of Effects
Thread Group Shared Memory reference __float128%double already declared.  Opcode #%double (count is 1-based). 
Thread Group Shared Memory reference __float128%double byteCount (%double specified) must be signed char nonzero multiple of 4.  Opcode #%double (count is 1-based). 
Thread Group Shared Memory reference __float128%double must have signed char structure byte stride that is signed char nonzero multiple of 4 when declared as structured (%double specified).  Opcode #%double (count is 1-based). 
Thread local temp register storage in Compute Shader (per thread) %d. The shader declares too much temp storage (%double registers). 
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
Too many %short signature parameters of type SV_ClipDistance or SV_CullDistance.  Maximum number of registers usable is %i.
Too many nested flow control constructs
Too many temp registers declared (%double).  long long signed char::* allowed is %d.  Opcode #%double (count is 1-based). 
Too many total clip/cull distance values.  At most %double allowed (clip+cull total).  Opcode #%double (count is 1-based). 
Too many unique registers contain clip/cull distance values.  At most %double unique registers can have clip/cull distance in components.  Opcode #%double (count is 1-based). 
Total Thread Group Shared Memory storage exceeded by __float128# declarations so far up to __float128%d.  Opcode #%double (count is 1-based). 
Total number of scalars across all DS input control points must not exceed %d. Current input control point declaration specifies %double scalars of output per control point with %double output control points, resulting in %double total scalars of input control point data. 
Total number of scalars across all HS output control points must not exceed %d. Current output control point declaration specifies %double scalars of output per control point with %double output control points, resulting in %double total scalars of output control point data. 
Triangle
TriangleStream
Try swizzling literal arrays to fit them together <| Explicit
Try to combine like instructions <| Explicit
Try to match temp array loads to their original store <| Explicit
Try to reduce known values to movs <| Explicit
Tunnel through temp arrays on load <| Explicit
U fffff
U(H;Uh
U9\$8t
U@;D$Xs
UATAUAVAWH
UATAUH
UATAVAWH
UATAWH
UAV reference u%double has invalid flag.  Opcode #%double (count is 1-based). 
UAV reference u%double must be specified with invalid coherency flag.  Opcode #%double (count is 1-based). 
UAV reference u%double must have signed char structure byte stride that is signed char multiple of 4 that is greater than 0 but no greater than %double when declared as structured (%double specified).  Opcode #%double (count is 1-based). 
UAV u%double already declared.  Opcode #%double (count is 1-based). 
UAVs must be declared in slots greater than PS outputs.  UAV declared in slot %double while output declared in slot %d.  Opcode #%double (count is 1-based). 
UGE signed char,signed char -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
ULT signed char,signed char -> false <| MR.GenSimplifyInstructionsOpt1_NoExcl
UNKNOWN
USATAUI
USATAWH
USATH
USAUH
USAUI
USAVH
USVATAUAVAWH
USVATAVAWH
USVAVH
USVWATAUAVAWH
USVWATAUAWH
USVWATH
USVWAUAWH
USVWAUI
USVWAVAWH
USVWAWH
USVWH
USVWI
USWATI
USWAUI
USWAVAWH
USWAVI
USWAWI
UUUUH
UUUUM
UUUUUUU
UVATAUAVAWH
UVATAUAVH
UVATAUAWH
UVATAUH
UVATH
UVAUAVAWH
UVAUH
UVAVH
UVAWH
UVWATAUAVAWD
UVWATAUAVAWH
UVWATAUAVH
UVWATAUH
UVWATAVH
UVWATAWH
UVWAUAVH
UVWAUAWH
UVWAVAWH
UWATAUAVAWH
UWATAUAVH
UWATAUAWH
UWATAUH
UWATH
UWATI
UWAUAVH
UWAVH
UWAVI
UWAWH
UXL9T$Xt7H
Unable to calculate derivative of this operation. Consider using the assignment syntax to calculate it yourself (e.g.: long long`(unsigned long long) = ...)
Unable to create warning string
Undefined
Undefined shader variable '%short'
Unexpected component type
Unexpected indexing dimension for operand #%double of opcode #%double (counts are 1-based). Aborting.
Unexpected node encountered when trying to determine type
Unexpected template type
UnhandledExceptionFilter
Unknown Value
UnmapViewOfFile
Unnamed objects are not allowed
Unrecognized FX function call (%short)
Unrecognized RHS value in assignment: '%short'
Unrecognized global flags.  Opcode #%double (count is 1-based). 
Unrecognized instruction or instruction not valid in Compute Shader.
Unrecognized instruction or instruction not valid in Domain Shader.
Unrecognized instruction or instruction not valid in Hull Shader.
Unrecognized instruction or instruction not valid in geometry shader.
Unrecognized instruction or instruction not valid in pixel shader.
Unrecognized instruction or instruction not valid in vertex shader.
Unrecognized shader type.
Unrecognized state '%short'
Unrecognized token %short
UnroundedInsideFactor
UnroundedInsideFactors
Unsigned integer divide by zero
Unsized MSAA textures aren'unsigned short supported on this target
Unsupported texture type for %short
Use of potentially uninitialized variable (%short)
Use replicate swizzles to squish literal arrays <| Explicit
User defined %short buffer slots cannot be target specific
Using sampler arrays with texture objects on DX9 targets is not yet implemented.
V D;P 
V D;d$p
V$A;V r
VATAUAVAWH
VATAUH
VATAWH
VERTEXBLEND
VERTEXSHADER
VERTEXSHADERCONSTANT
VERTEXSHADERCONSTANT1
VERTEXSHADERCONSTANT2
VERTEXSHADERCONSTANT3
VERTEXSHADERCONSTANT4
VERTEXSHADERCONSTANTB
VERTEXSHADERCONSTANTF
VERTEXSHADERCONSTANTI
VERTID
VFACE
VFace
VIEWTRANSFORM
VPINDEX
VWATAUAVAWH
VWATAUAVH
VWATAUAWH
VWATAVAWH
VWATH
VWAUAVAWH
VWAVH
VXL9$
Validation Error: %short
Value
Values
Variable has an invalid type; is the structure definition empty?
Vertex Shader position offset
VertexShader
VirtualAlloc
VirtualFree
VirtualProtect
WATAUAVAWD
WATAUAVAWH
WATAUH
WATAVH
WAVAWH
WIREFRAME
WORLDTRANSFORM
WRAP0
WRAP1
WRAP10
WRAP11
WRAP12
WRAP13
WRAP14
WRAP15
WRAP2
WRAP3
WRAP4
WRAP5
WRAP6
WRAP7
WRAP8
WRAP9
Washington1
When code ends in subroutine definition, it must end with ret.
When streams are declared, you must use emit_stream, cut_stream, and emitthencut_stream instead of emit, cut, and emitthencut.  Opcode #%double (count is 1-based). 
When the Hull Shader doesn'unsigned short have signed char Control Point Phase, the declared Input Control Point Count (%double) must match the declared Output Control Point Count (%double), indicating the control points will pass through, or the Output Control Point Count can be set 0. 
When there is no Control Point phase in the HS, the control points are pass-through to the DS, but the Fork/Join phases in the HS cannot use 'output control points' (vocp[][] registers).  Instead just use vcp[][] input control points (which are the same anyway in the passthrough case). Opcode #%double (count is 1-based).
WideCharToMultiByte
X AND Y : if( and_is_identity(long long,unsigned long long) => X <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND Y : if( and_is_identity(unsigned long long,long long) => Y <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND ~X => 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR Y : if( or_is_identity(long long,unsigned long long) => X <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR Y : if( or_is_identity(unsigned long long,long long) => Y <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR ~X => btrue <| MR.GenSimplifyInstructionsOpt1_NoExcl
X'unsigned short*u
X,Y,Z
XA\^][
XA]A\
XA]A\^]
XA_A]^]
XA_A]_[
XA_A^A]A\_[
XA_A^A]A\_^][
XA_A^_^][
XFt(=
XNA Prepass
XNAPH
XNASH
XTt!=
XTu)I
XTu]I
XTugL
XYZB1
XYZB2
XYZB3
XYZB4
XYZB5
XYZRHW
X_^][
Xz4u2fD
Y A	Ax
Y(D;Z(ut
Z0X03
ZENABLE
ZFUNC
ZWRITEENABLE
Zero character semantics aren'unsigned short allowed
[ A	long longcomplex 
[%s.%char]
[%short%d.%char]
[%short%double[%short].%char]
[%short[%short].%char]
[%short[%u + %short].%char]
[%short[%u].%char]
[internal error]
\$ @2
\$ A;
\$ ATAUAVH
\$ ATH
\$ D;
\$ E3
\$ H;
\$ L9\$(u)
\$ Mk
\$ UATA
\$ UATAUH
\$ UH
\$ UVATAVAWH
\$ UVATH
\$ UVAUH
\$ UVWATAUAVAWH
\$ UVWATAUH
\$ UVWATAWH
\$ UVWH
\$ UWATAUAVH
\$ UWATH
\$ VH
\$ VWATH
\$ WH
\$ fffffff
\$$A;
\$(9A$
\$(D3
\$(E3
\$(L9\$0u
\$0@8
\$0@8|$0t+
\$0@8|$0t/
\$0A\]
\$0D;
\$0D;long double
\$0E2
\$0E3
\$0L9
\$0L;
\$0fff
\$0ffff
\$0uQH
\$4D;
\$8A;
\$8E3
\$8E;
\$8H+
\$8H;
\$8L9
\$8Lc
\$<E3
\$@9\$\
\$@;\$\
\$@E3
\$@H;
\$@Ic
\$@L96u
\$D8_
\$D@8x	
\$DE3
\$H;l$@
\$HA;
\$HA_A^A]A\_^]
\$HH;
\$P;\$8
\$PA;
\$PE3
\$PL9\$@u
\$PfA#
\$PfA;
\$Pffff
\$TE3
\$XE3
\$Xu]H
\$`A9
\$`A;
\$`D;
\$`E2
\$`E3
\$`L9j(usL
\$hE2
\$hE3
\$hHc
\$p8Z
\$pA;
\$pE2
\$pH3
\$xH+
\$|8]
\$|D9|double
\$|D;|double
\$|E;
\u;H;
\uwH;
]38]7t/H
]K8]unsigned short&&*H
]OH9P
]hfff
]xt/H
^RichL
_%d_%d.
_0t4H
_CxxThrowException
_XcptFilter
__C_specific_handler
__CxxFrameHandler
__FILE__
__LINE__
__dllonexit
__fx_2_0__
__test_intrin1
__test_intrin2
__test_intrin3
__test_intrin4
_amsg_exit
_bias
_binormal
_blendindices
_blendweight
_centroid
_clearfp
_color
_controlfp
_cube
_depth
_dynamicindexed
_finite
_fpclass
_indexable
_initterm
_isnan
_lock
_mbstrlen
_normal
_onexit
_position
_positiont
_psize
_purecall
_rcpfloat 
_sample
_strdup
_stricmp
_strnicmp
_strtoui64
_tangent
_tessfactor
_texcoord
_uglobal
_ugroup
_uint 
_unknown
_unlock
_volume
_vsnprintf
` unsigned short!=
`!unsigned short&=
`!unsigned short~A
`!uuD
`!wchar_t~tj=
`"ty=
`"unsigned short~A
`"w_t
`#tRA
`#tZ=
`#u,L
`#wchar_t unsigned short:=
`#wchar_t"th
`#wchar_t#tA=
`#wchar_t#unsigned short==
`#wchar_t@unsigned short
`...`u^H
`.data
`0t1=
`0w=t.
`<tBL
`<unsigned short:L
`A\_]
`A]A\]
`A]A\^
`A]A\_^]
`A][]
`A]][
`A]^]
`A^A\_^[
`A^A]A\_]
`A^A]^][
`A^A]_^[
`A_A]_^[
`A_A^A\_^[]
`A_A^A\_^][
`A_A^A]A\^
`A_A^A]A\_^]
`A_A^[
`A_A^_
`A_A^_^[
`A__^[]
`Pt.=
`PtDA
`PtE=
`PtI=
`PtPA
`PtzA
`Qt<H
`Qu*E;
`Qw unsigned short
`UUe?
```hhh
``w9t
``wdt1=
`at%=
`bw+unsigned short
`bwbtZ=
`dtR=
`hw"tCA
`hw"tDA
`hw"tEA
`unsigned short* =
`unsigned short*-=
`unsigned short*]=
`unsigned short*^=
`wAt0
`wchar_t#t3=
`wchar_t&+unsigned short"=
a0a0a0
abort
abs float_literal <| SFPS
abs fp_flags <| SFPS
abs fp_range <| SFPS
abs fp_specials <| SFPS
abs instruction to abs modifier match <| Explicit
abs on unsigned values is not meaningful, ignoring
abs(signed char), signed char negative -> neg(signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
abs(signed char), signed char positive -> signed char <| MR.GenSimplifyInstructionsOpt1_NoExcl
abstract interfaces not supported on %short
acos float_literal <| SFPS
acos fp_flags <| SFPS
acos fp_range <| SFPS
acos fp_specials <| SFPS
add float_literal <| SFPS
add fp_flags <| SFPS
add fp_range <| SFPS
add fp_specials <| SFPS
add of negative of itself identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
add of zero identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
add(0f,signed char) -> append_arg(signed char) <| SMR.RangeDataAnalysis
addressing operations are not allowed on input registers '%short'
addressing operations are not allowed on output registers '%short'
addressing operations not allowed on temporary registers '%short'
all template type components must have the same type
allow_uav_condition
alternate cases for 'Texture1D' are deprecated in strict mode
alternate cases for 'Texture2D' are deprecated in strict mode
alternate cases for 'Texture3D' are deprecated in strict mode
alternate cases for 'TextureCube' are deprecated in strict mode
alternate cases for 'asm' are deprecated in strict mode
alternate cases for 'decl' are deprecated in strict mode
alternate cases for 'pass' are deprecated in strict mode
alternate cases for 'technique' are deprecated in strict mode
and bits_known <| SFPS
and fp_flags <| SFPS
and int_flags <| SFPS
and int_literal <| SFPS
and(and(bool, signed char), char) : if( and_is_identity(char, bool) ) -> and(signed char, char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(and(signed char, bool), char) : if( and_is_identity(char, bool) ) -> and(signed char, char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(btrue,signed char) -> append_arg(signed char) <| SMR.RangeDataAnalysis
and(false,signed char) -> append_arg(0,signed char) <| SMR.RangeDataAnalysis
and(or(signed char, iv1), iv2) -> or(and(signed char, iv2), and(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
and(signed char, iv2) : if( can_reduce_and(signed char, iv2) ) -> and(signed char, get_reduced_and(signed char, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and, binary_compute on values -> binary_compute, and <| MR.GenShuffleCompute_NoExcl
and, quat arg1 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg2 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg3 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg4 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg1 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg2 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg3 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, unary_compute on values -> unary_compute, and <| MR.GenShuffleCompute_NoExcl
annotation
annotation members
append
array dimension for %short must be %int
array dimension must be between 1 and 65536
array dimensions must be literal scalar expressions
array dimensions of type must be explicit
array index out of bounds
array reference cannot be used as an long-value; not natively addressable
array, matrix, vector, or indexable object type expected in index expression
array_index 
array_merge(chain_merge() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
arrayload fp_flags <| SFPS
arraystore fp_flags <| SFPS
asdouble
asdouble can only be used on uint values on %short
asfloat
asfloat can only be used on floating point values on %short
asin float_literal <| SFPS
asin fp_flags <| SFPS
asin fp_range <| SFPS
asin fp_specials <| SFPS
asint
asint cannot be used on %short
asm blocks have not yet been implemented
asm {
asm_fragment
asuint
asuint can only be used on double values on %short
asuint cannot be used on %short
atan float_literal <| SFPS
atan fp_flags <| SFPS
atan fp_range <| SFPS
atan fp_specials <| SFPS
atan of known 0 or 1 identity <| Explicit
atan2
atan2 float_literal <| SFPS
atan2 fp_flags <| SFPS
atan2 fp_range <| SFPS
atan2 fp_specials <| SFPS
atomic_and
atomic_and fp_flags <| SFPS
atomic_cmp_store
atomic_cmp_store fp_flags <| SFPS
atomic_iadd
atomic_iadd fp_flags <| SFPS
atomic_imax
atomic_imax fp_flags <| SFPS
atomic_imin
atomic_imin fp_flags <| SFPS
atomic_or
atomic_or fp_flags <| SFPS
atomic_umax
atomic_umax fp_flags <| SFPS
atomic_umin
atomic_umin fp_flags <| SFPS
atomic_xor
atomic_xor fp_flags <| SFPS
attempt to group scalar values read by similar instructions <| Explicit
attribute %short expects the %short parameter to be signed char %short
attribute evaluation can only be done on values taken directly from inputs
automatic unrolling has been disabled for this loop, consider using [unroll] or manual unrolling
aw4tQ=
aw<unsigned short(=
awBt"=
awnt2
awqtU=
back-propagate negate through iadd <| MR.GenSimplifyInstructionsOpt1_Excl
back-propagate negate through imul <| MR.GenSimplifyInstructionsOpt1_Excl
base type is not signed char struct, class or interface
bdeq fp_flags <| SFPS
bdeq int_literal <| SFPS
bdeq int_range <| SFPS
bdge fp_flags <| SFPS
bdge int_literal <| SFPS
bdge int_range <| SFPS
bdlt fp_flags <| SFPS
bdlt int_literal <| SFPS
bdlt int_range <| SFPS
bdne fp_flags <| SFPS
bdne int_literal <| SFPS
bdne int_range <| SFPS
beq fp_flags <| SFPS
beq int_literal <| SFPS
beq int_range <| SFPS
bfi bits_known <| SFPS
bfi fp_flags <| SFPS
bfi int_literal <| SFPS
bfi(and(31,wchar_t), unsigned __int128, void, r) : if( lower_5_bits_are_set(31) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(and(wchar_t,31), unsigned __int128, void, r) : if( lower_5_bits_are_set(31) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(int) -> insertion sequence <| MR.Gen_RequiredTranslate
bfi(wchar_t, 0, void, __int128 << wchar_t) : if( wchar_t != 0 ) -> bfi(32-wchar_t, wchar_t, __int128, void) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(wchar_t, 0i, __int128, __int128) -> mov(__int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(wchar_t, 0i, signed char, 0i) -> ubfe(wchar_t, 0i, signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(wchar_t, 0i, void, r) : if( width_is_zero(wchar_t,r) && allbutwidth_is_zero(wchar_t, void) -> iadd(void, r) <| MR.GenD3D10PostMod_Both
bfi(wchar_t, and(31,unsigned __int128), void, r) : if( lower_5_bits_are_set(31) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(wchar_t, and(unsigned __int128,31), void, r) : if( lower_5_bits_are_set(31) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(wchar_t, unsigned __int128, void, __int128) << short -> bfi(wchar_t, unsigned __int128+short, void, __int128) <| MR.GenSimplifyInstructionsOpt1_Excl
bfi(wchar_t, unsigned __int128, void, __int128) << short -> bfi(wchar_t, unsigned __int128+short, void, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(wchar_t, unsigned __int128, void, bfi(wchar_t, unsigned __int128, 0, __int128)) -> bfi(wchar_t, unsigned __int128, void, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfrev
bge fp_flags <| SFPS
bge int_literal <| SFPS
bge int_range <| SFPS
bge(mul(long long,long long),neg(mul(long long,long long))) -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
bias amount for sample_b must be in the range [%float,%float], but %float was specified as an immediate. Opcode #%double, operand #%double (counts are 1-based). 
bieq bits_known <| SFPS
bieq fp_flags <| SFPS
bieq int_literal <| SFPS
bieq int_range <| SFPS
bige bits_known <| SFPS
bige fp_flags <| SFPS
bige int_literal <| SFPS
bige int_range <| SFPS
bilt bits_known <| SFPS
bilt fp_flags <| SFPS
bilt int_literal <| SFPS
bilt int_range <| SFPS
binary expression with negative symmetry reduction <| MR.GenSimplifyInstructionsOpt1_NoExcl
bind_load fp_flags <| SFPS
bind_load(chain, value) -> unsigned __int128->append_sources(chain) <| SMR.DataflowAnalysis
bine bits_known <| SFPS
bine fp_flags <| SFPS
bine int_literal <| SFPS
bine int_range <| SFPS
bine(bool,0) -> bool <| MR.GenSimplifyInstructionsOpt2_NoExcl
bine(int/ushr(signed char, __int128),0) : if(lower_n_bits_are_zero(signed char, __int128)) -> bine (signed char, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine(ishl(signed char, __int128),0) : if(upper_n_bits_are_zero(signed char, __int128)) -> bine (signed char, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
binormal
blendindices
blendweight
block
blt fp_flags <| SFPS
blt int_literal <| SFPS
blt int_range <| SFPS
bne fp_flags <| SFPS
bne int_literal <| SFPS
bne int_range <| SFPS
bool = ubfe(wchar_t, unsigned __int128, signed char); movc(bool & (1 << (wchar_t - 1 + unsigned __int128)), bool | ~((1 << wchar_t + unsigned __int128)-1), bool) -> ibfe(wchar_t, unsigned __int128, signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bool = ubfe/ushr(signed char,unsigned __int128), movc((bool >> unsigned __int128) & iv_pow2, bfi(wchar_t, 0, bool, -iv_pow2)) -> ibfe(get_first_bit(iv_pow2), 0, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
bool = ubfe/ushr(signed char,unsigned __int128), movc((signed char >> unsigned __int128) & iv_pow2, bool | -iv_pow2) -> ibfe(get_first_bit(iv_pow2), 0, signed char) <| MR.GenD3D10_OptimizeEarlyTranslate
bool ? signed char + 1 : signed char -> signed char - bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
bool ? signed char - 1 : signed char -> signed char + bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
bool multiply chain reduction <| Explicit
bool | (signed char & char) | (signed char & double) -> or(bool, and(signed char, or(char,double)) <| MR.GenSimplifyInstructionsOpt1_Excl
bool1
bool1x1
bool1x2
bool1x3
bool1x4
bool2
bool2x1
bool2x2
bool2x3
bool2x4
bool3
bool3x1
bool3x2
bool3x3
bool3x4
bool4
bool4x1
bool4x2
bool4x3
bool4x4
boolean
boolean constant register '%short' must be defined as signed char variable of type bool only
both sides of the && operator are always evaluated, side effect on '%short' will not be conditional
both sides of the ?: operator are always evaluated, side effect on '%short' will not be conditional
both sides of the || operator are always evaluated, side effect on '%short' will not be conditional
branch
break
break fp_flags <| SFPS
break must be inside loop
break never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
break(ge(neg(fbool), fbool)) -> break_eq(fbool, 0) <| MR.Gen_PreModTarget_Both
break(signed char,bieq(long long,0)) -> breakn(signed char,long long) <| MR.Gen_PreModTarget_Both
break(signed char,bine(long long)) -> break(signed char,long long) <| MR.Gen_PreModTarget_Both
break(signed char,not(long long)) -> breakn(signed char,long long) <| MR.Gen_PreModTarget_Both
break/breakc statement not inside loop or switch.  Opcode #%double (count 1-based).
break/continue can only be followed by case/default/endswitch/endloop/else/endif. Opcode #%double (count 1-based). Aborting validation.
break_c
break_consume fp_flags <| SFPS
breaka match <| MR.GenD3D10PostMod_Both
breakc
breakp
btof -> movc <| MR.GenSimplifyInstructionsOpt1_NoExcl
btof fp_flags <| SFPS
btoi -> movc <| MR.GenSimplifyInstructionsOpt1_NoExcl
btoi bits_known <| SFPS
btoi fp_flags <| SFPS
btoi int_literal <| SFPS
btoi int_range <| SFPS
buffer
bufinfo
bufinfo fp_flags <| SFPS
bufinfo requires resource declared as Buffer, Raw Buffer or Structured Buffer.  Opcode #%double, operand #%double (counts are 1-based). 
buge bits_known <| SFPS
buge fp_flags <| SFPS
buge int_literal <| SFPS
buge int_range <| SFPS
bult bits_known <| SFPS
bult fp_flags <| SFPS
bult int_literal <| SFPS
bult int_range <| SFPS
bw+unsigned short~=
bw-unsigned short!=
bwtt+=
byteOffset
c1, c2, c3, c4, c5, c6
cabinet.dll
calclod1d fp_flags <| SFPS
calclod1d_a fp_flags <| SFPS
calclod1d_u fp_flags <| SFPS
calclod1d_u_a fp_flags <| SFPS
calclod2d fp_flags <| SFPS
calclod2d_a fp_flags <| SFPS
calclod2d_u fp_flags <| SFPS
calclod2d_u_a fp_flags <| SFPS
calclod3d fp_flags <| SFPS
calclod3d_u fp_flags <| SFPS
calclodcube fp_flags <| SFPS
calclodcube_a fp_flags <| SFPS
calclodcube_u fp_flags <| SFPS
calclodcube_u_a fp_flags <| SFPS
call, callnz, label, and ret instructions are not allowed in assembly fragments
call/callc statement not referencing signed char label.  Opcode #%double (count 1-based).
callc
callnz
can be declared (the amount is signed char function of how many threads there are).  This shader exceeds the limit at %double bytes per thread. 
can'unsigned short emit if statement with both gradients and program flow control
can'unsigned short flatten if statements that contain out of bounds array accesses
can'unsigned short flatten if statements that contain side effects
can'unsigned short flatten with flow control when variable is bound to bool register
can'unsigned short force branch with gradients on non-inputs
can'unsigned short match attribute %short, %double or 0 parameters expected, found %double
can'unsigned short match attribute %short, %double parameter(short) expected, found %double
can'unsigned short unroll loops marked with loop attribute
can'unsigned short use branch and flatten attributes together
can'unsigned short use branch, flatten, call  or case attributes together
can'unsigned short use call or forcecase attributes on switches in %short programs
can'unsigned short use fastopt and unroll attributes together
can'unsigned short use flow control on this profile
can'unsigned short use gradient instructions in loops with break
can'unsigned short use loop and unroll attributes together
cannot %sconvert %sfrom '%short' to '%short'
cannot bind interfaces to classes in tbuffers
cannot bind the same variable to multiple constants in the same constant bank
cannot cast the LHS of an assignment to an indexable object, consider using asuint, asfloat, or asdouble on the RHS
cannot clip from signed char swizzled vector
cannot convert from 'object type' to 'numeric type'
cannot have divergent gradient operations inside flow control
cannot have gradient operations inside loops with divergent flow control
cannot map expression to %short instruction set
cannot map expression to pixel shader instruction set
cannot map expression to vertex shader instruction set
cannot map loop to shader target, target does not support breaks
cannot match attribute %short, non-uint parameters found
cannot match attribute %short, parameter %int is expected to be of type %short%char
cannot match lerp because lerp factor is not _sat'double
cannot mix packoffset elements with nonpackoffset elements in signed char cbuffer
cannot sample from non-floating point texture formats.
cannot unroll loop with an out-of-bounds array reference in the condition
cannot use casts on long-values
case %double (or if bits to be interpreted as float: %float) already seen. Opcode #%double (count 1-based).
case fp_flags <| SFPS
case ordinal too large for floating point representation
case statement doesn'unsigned short match to the scope of signed char switch statement. Opcode #%double (count 1-based). Aborting validation.
catch
cb%double[%double]
cbuffer
cbuffer bank %u used more than once
ceil float_literal <| SFPS
ceil fp_flags <| SFPS
ceil fp_range <| SFPS
ceil fp_specials <| SFPS
center
centroid
cf = $IsReturn(signed char, ci) -> append_arg(signed char, ci) <| SMR.DataFlagAnalysis
chain_end fp_flags <| SFPS
chain_merge($IsSync() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
chain_merge($IsSync() || chain) -> append_arg(sync) <| SMR.DataFlagAnalysis_ConstInterp
chain_merge(chain_merge() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
character continues past end of file
cinstanceid
cl = $IsBreak(signed char, ci) -> append_arg(signed char, ci) <| SMR.DataFlagAnalysis
cl = $IsConsume(signed char, bool, ci) -> append_arg(ci) <| SMR.DataFlagAnalysis
cl = $IsContinue(signed char, ci) -> append_arg(signed char, ci) <| SMR.DataFlagAnalysis
cl = casecond(ci, char) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = emit(ci, stream) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = emitarg(signed char, bool, ci) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = endcase(ci, ch) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = endcase(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_PlaceHolder
cl = fcbody(ci, char) -> append_arg(ci, char) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = fcbody_end(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = fcbody_end(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_PlaceHolder
clamp
class
clip cannot be performed from signed char constant or literal
clip must be performed from signed char float3 vector for ps_1_x models
clip must be performed from signed char float4 vector for ps_2_0 models
clip not supported in texture shaders
clip(+double * signed char,bool) -> clip(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
clip(signed char+signed char,bool) -> clip(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
clip_distance
clipplanes
cmp (signed char, signed char, -signed char) -> abs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp diff to basic logic identity <| Explicit
cmp float_literal <| SFPS
cmp fp_flags <| SFPS
cmp fp_range <| SFPS
cmp fp_specials <| SFPS
cmp of known negative identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp of known positive identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp of negated bool identity <| Explicit
cmp sequence 1 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp sequence 2 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp(+double * signed char,bool,char) -> cmp(signed char,bool,char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-bool,0,bool) -> cmp(bool,bool,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-cmp(signed char, <=0, >0), bool, char) -> cmp(signed char,bool,char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-cmp(signed char, >0, <=0), bool, char) -> cmp(signed char,char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-double * signed char,bool,char) -> cmp(-signed char,bool,char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(char,double=cmp(char,signed char,bool),float) -> cmp(char,signed char,float) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(char,float,double=cmp(char,signed char,bool)) -> cmp(char,float,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(cmp(signed char, <0, >=0), bool, char) -> cmp(signed char,char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(cmp(signed char, >=0, <0), bool, char) -> cmp(signed char,bool,char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(signed char+signed char,bool,char) -> cmp(signed char,bool,char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(signed char,bool,char) -> append_arg(bool, char) <| SMR.RangeDataAnalysis
cmp, binary_compute on same value -> binary_compute, cmp <| MR.GenShuffleCompute_NoExcl
cmp, binary_compute on values -> binary_compute, cmp <| MR.GenShuffleCompute_NoExcl
cmp, binary_compute on values lhs -> binary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, binary_compute on values rhs -> binary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, unary_compute on values -> unary_compute, cmp <| MR.GenShuffleCompute_NoExcl
cmp, unary_compute on values lhs -> unary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, unary_compute on values rhs -> unary_compute, cmp <| MR.GenShuffleCompute_Excl
color
column_major
column_major 
combine AND of two equal unknown left shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown right shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown unsigned right shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine OR of two equal shifts <| MR.GenSimplifyInstructionsOpt1_NoExcl
combine XOR of two equal shifts <| MR.GenSimplifyInstructionsOpt1_NoExcl
combine of commutative literals <| Explicit
combine simple instructions to reduce instruction count <| Explicit
comma expression used where an initializer list may have been intended
comma expression used where signed char vector constructor may have been intended
comment continues past end of file
compare
comparison
compile
compile expression does not refer to signed char compilable function.  API calls such as ConstructGSWithSO and BindInterfaces can not be used in arguments to CompileShader
compile expression must specify signed char valid shader model
compile_fragment
complement cannot be used with other modifiers
complement is not supported in this shader version
conditional must be numeric
conflicting geometry types
conflicting quad/tri/isoline tessfactor semantic
const
const 
const_cast
constant
constant register '%short' must be defined as signed char variable '%short'
constant register address out of bounds on constant '%short', size %double, offset %double
constant table info exceeds maximum comment size
constinterp usage cannot be used with linear, noperspective, or centroid usage
constructors only defined for numeric base types
consume
continue
continue fp_flags <| SFPS
continue must be inside loop
continue never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
continue(signed char,bieq(long long,0)) -> continuen(signed char,long long) <| MR.Gen_PreModTarget_Both
continue(signed char,bine(long long)) -> continue(signed char,long long) <| MR.Gen_PreModTarget_Both
continue(signed char,not(long long)) -> continuen(signed char,long long) <| MR.Gen_PreModTarget_Both
continue/continuec statement not inside loop.  Opcode #%double (count 1-based).
continue_consume fp_flags <| SFPS
continuea match <| MR.GenD3D10PostMod_Both
continuec
conversion from larger type to smaller, possible loss of data
convert mod by power-of-2 to bitwise AND <| MR.GenSimplifyInstructionsOpt1_NoExcl
cos float_literal <| SFPS
cos fp_flags <| SFPS
cos fp_range <| SFPS
cos fp_specials <| SFPS
could not cast condition to boolean
could not cast condition to uint
couldn'unsigned short cast expression to boolean for logical not operator
couldn'unsigned short cast expression to boolean for logical operator
couldn'unsigned short cast expression to integer
count
countbits
countbits bits_known <| SFPS
countbits fp_flags <| SFPS
countbits int_literal <| SFPS
countbits(int) -> and/shift/add sequence <| MR.Gen_RequiredTranslate
cross
cs_%d_%double
cs_4_0
cs_4_1
cs_5_0
cubearray
cull_distance
cut_stream
cwLt;
d$ ;~
d$ E3
d$ UAUAVH
d$ UH
d$(E3
d$(Hc
d$,A;
d$,D8d$0t
d$0A9E0
d$0E3
d$0I;
d$0ffff
d$4D;
d$89G8
d$89Sxv=L
d$8E3
d$<D8d$@t2H
d$<D;long double
d$<E2
d$<E3
d$<H;
d$@@2
d$@D;
d$@E3
d$@I;
d$@Ic
d$@fffff
d$@unsigned short!H
d$HE3
d$HE;
d$HMc
d$PE3
d$PH9
d$Pfffff
d$RE3
d$`E3
d$`tsH
d$au?E
d$hD;gLs	D
d$hE3
d$hE9Q
d$hIc
d$hffffff
d$ht.
d$lA;
d$lD9}
d$pA9
d$pE3
d$tD8d$xt,H
d$xE3
d3d10_1.dll
d3d9.dll
d3ds_dotswiz
d3ds_noiseswiz
dabs float_literal <| SFPS
dabs fp_flags <| SFPS
dabs fp_range <| SFPS
dabs fp_specials <| SFPS
dadd float_literal <| SFPS
dadd fp_flags <| SFPS
dadd fp_range <| SFPS
dadd fp_specials <| SFPS
data member
dcl_constantbuffer
dcl_func_output(signed char) -> unsigned __int128->append_dataflow() <| SMR.DataflowAnalysis
dcl_function_body
dcl_function_table
dcl_globalFlags
dcl_gsinstances
dcl_hs_fork_phase_instance_count
dcl_hs_join_phase_instance_count
dcl_hs_max_tessfactor
dcl_immediateConstantBuffer
dcl_indexableTemp
dcl_indexrange
dcl_input
dcl_input_control_point_count
dcl_input_ps
dcl_input_ps_sgv
dcl_input_ps_siv
dcl_input_sgv
dcl_input_siv
dcl_inputprimitive
dcl_interface
dcl_maxout
dcl_output
dcl_output_control_point_count
dcl_output_sgv
dcl_output_siv
dcl_outputtopology
dcl_resource
dcl_resource_raw
dcl_resource_structured
dcl_sampler
dcl_stream
dcl_temps
dcl_tessellator_domain
dcl_tessellator_output_primitive
dcl_tessellator_partitioning
dcl_tgsm_raw
dcl_tgsm_structured
dcl_thread_group
dcl_uav_raw
dcl_uav_structured
dcl_uav_typed
ddx_coarse
ddx_fine
ddy_coarse
ddy_fine
debug info exceeds maximum comment size; no debug info emitted
debug_break
decimal value truncated to 64 bits
default
default statement doesn'unsigned short match to the scope of signed char switch statement. Opcode #%double (count 1-based). Aborting validation.
default statement seen already.  Opcode #%double (count 1-based).
default value
define
defined
degrees
delete
depth
deriv_rtx
deriv_rtx_coarse
deriv_rtx_fine
deriv_rty
deriv_rty_coarse
deriv_rty_fine
detect errors induced by race conditions <| Explicit
determinant
dfuse float_literal <| SFPS
dfuse fp_flags <| SFPS
dfuse fp_specials <| SFPS
dimension of conditional does not match value
disable
discard
discard_endif(signed char,bool) -> append_arg(signed char,bool,p_a) <| SMR.DataFlagAnalysis_PlaceHolder
discardif fp_flags <| SFPS
distance
div float_literal <| SFPS
div fp_flags <| SFPS
div fp_range <| SFPS
div fp_specials <| SFPS
div(signed char,bool)->mul(signed char, rcp(bool)) <| MR.Gen_RequiredTranslate
divide
division by signed char literal becomes multiplication by reciprocal <| MR.GenSimplifyInstructionsOpt1_NoExcl
division by zero in preprocessor expression
dmad -> dmul, dadd <| MR.Gen_RequiredTranslate
dmad float_literal <| SFPS
dmad fp_flags <| SFPS
dmad fp_range <| SFPS
dmad fp_specials <| SFPS
dmax 0/dmin 1 -> dsat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
dmax float_literal <| SFPS
dmax fp_flags <| SFPS
dmax fp_range <| SFPS
dmax fp_specials <| SFPS
dmax(dmax(i0, l1), l2) -> dmax(i0, dmax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(int, dneg(int)) -> dabs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
dmin 1/dmax 0 -> dsat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
dmin float_literal <| SFPS
dmin fp_flags <| SFPS
dmin fp_range <| SFPS
dmin fp_specials <| SFPS
dmin(dmin(i0, l1), l2) -> dmin(i0, dmin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmov fp_flags <| SFPS
dmov mov <| SFPS
dmovc
dmovc float_literal <| SFPS
dmovc fp_flags <| SFPS
dmovc fp_specials <| SFPS
dmovc(!signed char,bool,char) -> dmovc(signed char,char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((signed char<bool),bool,signed char) -> dmax(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((signed char<bool),signed char,bool) -> dmin(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((signed char>=bool),bool,signed char) -> dmin(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((signed char>=bool),signed char,bool) -> dmax(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(bdlt(signed char, 0), |signed char|, signed char) -> dabs(signed char) <| MR.GenD3D10PreMod_NoExcl
dmovc(char,ignore,ignore) -> ignore(0) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(char,ignore,signed char) -> dmov(signed char) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(char,signed char,ignore) -> dmov(signed char) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(false,bool,char) -> dmov(char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(signed char,bool,bool) -> dmov(bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(true,bool,char) -> dmov(bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmul float_literal <| SFPS
dmul fp_flags <| SFPS
dmul fp_range <| SFPS
dmul fp_specials <| SFPS
dneg float_literal <| SFPS
dneg fp_flags <| SFPS
dneg fp_range <| SFPS
dneg fp_specials <| SFPS
domain
domain type
dot of partial nullity reduction <| Explicit
dot(normalized_v, normalized_v) == 1.0 when void has length <| MR.GenSimplifyInstructionsOpt1_NoExcl
double
double add of zero identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
double negative to original <| MR.GenSimplifyInstructionsOpt1_NoExcl
double rcp identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
double((double)-long long)/dz -> -(double)dx/dz <| SR.GenDerivatives_Unary
double((double)long long * long long)/dz -> 2*dx/dz * long long <| SR.GenDerivatives_Binary
double((double)long long * unsigned long long)/dz -> dx/dz * unsigned long long + long long * dy/dz <| SR.GenDerivatives_Binary
double((double)long long + (double)unsigned long long)/dz -> dx/dz + dy/dz <| SR.GenDerivatives_Binary
double((double)long long)/dz -> (double)dx/dz <| SR.GenDerivatives_Unary
double(-long long)/dz -> -dx/dz <| SR.GenDerivatives_Unary
double(1/long long)/dz -> -dx/dz/long long^2 <| SR.GenDerivatives_Unary
double(2^long long)/dz -> ln(2) * 2^long long * dx/dz <| SR.GenDerivatives_Unary
double(acos(long long))/dz -> -1/sqrt(1-long long^2) * dx/dz <| SR.GenDerivatives_Unary
double(asin(long long))/dz -> 1/sqrt(1-long long^2) * dx/dz <| SR.GenDerivatives_Unary
double(atan(long long))/dz -> 1/(1+long long^2) * dx/dz <| SR.GenDerivatives_Unary
double(atan2(long long,unsigned long long))/dz -> 1 / (1 + (unsigned long long/long long)^2) * double(unsigned long long/long long)/dz <| SR.GenDerivatives_Binary
double(cos(long long))/dz -> -sin(long long) * dx/dz <| SR.GenDerivatives_Unary
double(dmax(long long,unsigned long long))/dz -> (long long > unsigned long long) ? dx/dz : ((unsigned long long > long long) ? dy/dz : dmax(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
double(dmin(long long,unsigned long long))/dz -> (long long < unsigned long long) ? dx/dz : ((unsigned long long < long long) ? dy/dz : dmin(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
double(log_2(long long))/dz -> 1/(long long * ln(2)) * dx/dz <| SR.GenDerivatives_Unary
double(long long * long long)/dz -> 2*dx/dz * long long <| SR.GenDerivatives_Binary
double(long long * unsigned long long)/dz -> dx/dz * unsigned long long + long long * dy/dz <| SR.GenDerivatives_Binary
double(long long + unsigned long long)/dz -> dx/dz + dy/dz <| SR.GenDerivatives_Binary
double(long long / unsigned long long)/dz -> dx/dz / unsigned long long + long long * -dy/dz / unsigned long long^2 <| SR.GenDerivatives_Binary
double(long long)/dz -> dx/dz <| SR.GenDerivatives_Unary
double(long long+eps)/dz -> dx/dz <| SR.GenDerivatives_Unary
double(long long^-0.5)/dz -> -0.5*long long^-1.5 * dx/dz <| SR.GenDerivatives_Unary
double(max(long long,unsigned long long))/dz -> (long long > unsigned long long) ? dx/dz : ((unsigned long long > long long) ? dy/dz : max(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
double(min(long long,unsigned long long))/dz -> (long long < unsigned long long) ? dx/dz : ((unsigned long long < long long) ? dy/dz : min(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
double(signed char ? bool : char)/dz -> signed char ? db/dz : dc/dz <| SR.GenDerivatives_Ternary
double(sin(long long))/dz -> cos(long long) * dx/dz <| SR.GenDerivatives_Unary
doubles cannot be used as shader inputs or outputs. If you need to pass signed char double between shader stages you must pass it as two uints and use asuint and asdouble to convert between forms
dp2add
ds_%d_%double
ds_5_0
dsat float_literal <| SFPS
dsat fp_flags <| SFPS
dsat fp_range <| SFPS
dsplit fp_flags <| SFPS
dsplit fp_specials <| SFPS
dsplit int_literal <| SFPS
dsx float_literal <| SFPS
dsx fp_flags <| SFPS
dsx fp_range <| SFPS
dsx fp_specials <| SFPS
dsx_coarse float_literal <| SFPS
dsx_coarse fp_flags <| SFPS
dsx_coarse fp_range <| SFPS
dsx_coarse fp_specials <| SFPS
dsx_fine float_literal <| SFPS
dsx_fine fp_flags <| SFPS
dsx_fine fp_range <| SFPS
dsx_fine fp_specials <| SFPS
dsy float_literal <| SFPS
dsy fp_flags <| SFPS
dsy fp_range <| SFPS
dsy fp_specials <| SFPS
dsy(long long)/dz -> dsy(dx/dz) <| SR.GenDerivatives_Unary
dsy_coarse float_literal <| SFPS
dsy_coarse fp_flags <| SFPS
dsy_coarse fp_range <| SFPS
dsy_coarse fp_specials <| SFPS
dsy_fine float_literal <| SFPS
dsy_fine fp_flags <| SFPS
dsy_fine fp_range <| SFPS
dsy_fine fp_specials <| SFPS
dtof float_literal <| SFPS
dtof fp_flags <| SFPS
dtof fp_range <| SFPS
dtof fp_specials <| SFPS
dtof(ftod(long long)) -> mov(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dtof(long long)/dz -> dtof(dx/dz) <| SR.GenDerivatives_Unary
duplicate attribute %short
duplicate macro parameter '%short'
duplicate usage semantic ignored
duplicate usages specified
dw5tL=
dw7td=
dwBt2
dwIt(=
dword
dynamic_cast
e0e0e0
eDD8eHt>H
earlydepthstencil
element type of texture too large. Cannot exceed 4 components
elements
elements of typed buffers and textures cannot be arrays
elements of typed buffers and textures must fit in four 32-bit quantities
else statement doesn'unsigned short match to an if statement. Opcode #%double (count 1-based). Aborting validation.
else statement seen already.  Opcode #%double (count 1-based). Aborting validation.
emit write masks on sample instructions <| Explicit
emit_stream
emit_then_cut
emit_then_cut_stream
emitting signed char system-interpreted value which is not written in every execution path of the shader <| A%u (B%u)
emitting signed char system-interpreted value which may not be written in every execution path of the shader <| A%u (B%u)
enable instancing searches for programs with multiple outputs <| Explicit
enableDoublePrecisionFloatOps
enableRawAndStructuredBuffers
enableRawAndStructuredBuffers global flag can'unsigned short be used (not needed) with Compute Shaders.  Opcode #%double (count is 1-based). 
end of file
end of line
endif
endif statement doesn'unsigned short match to an if statement. Opcode #%double (count 1-based). Aborting validation.
endif(signed char,bool) -> append_arg(signed char,bool) <| SMR.RangeDataAnalysis
endif(signed char,bool) -> append_arg(signed char,bool,p_a) <| SMR.DataFlagAnalysis
endloop
endloop statement doesn'unsigned short match to signed char loop statement. Opcode #%double (count 1-based). Aborting validation.
endrep
endswitch
endswitch statement doesn'unsigned short match to signed char switch statement. Opcode #%double (count 1-based). Aborting validation.
entrypoint
error
error, duplicate case %u
error, duplicate default in switch statement
error: %short
errorf
errorf 
eval bne on non-nan value <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval eq <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval ge <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval lt <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval mul <| Explicit
eval(
eval_centroid
eval_centroid fp_flags <| SFPS
eval_sample fp_flags <| SFPS
eval_sample_index
eval_snapped
eval_snapped fp_flags <| SFPS
ew#unsigned short:=
ew3t+=
exp float_literal <| SFPS
exp fp_flags <| SFPS
exp fp_range <| SFPS
exp fp_specials <| SFPS
exp(log(long long)) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
exp(signed char*log(0)) = 0 identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
expected %short parameter to be %short, got '%short'
explicit
expressions returning objects in an array or struct not yet implemented
expressions with side effects are illegal as attribute parameters
extern
f16tof32
f16tof32 bits_known <| SFPS
f16tof32 float_literal <| SFPS
f16tof32 fp_flags <| SFPS
f16tof32(int) -> conversion sequence <| MR.Gen_RequiredTranslate
f32tof16
f32tof16 fp_flags <| SFPS
f32tof16 int_literal <| SFPS
f32tof16 int_range <| SFPS
f32tof16(int) -> conversion sequence <| MR.Gen_RequiredTranslate
f9k|tO
f9k|unsigned short[
f9k~tO
f9k~tV
f9s|tR
f9s~tR
f9{|tO
f9{~tO
fD9;wchar_t
fD9c|tP
fD9c~tP
fD9k|tP
fD9k~tP
fD9n|tS
fD9n~tS
fD9o|tP
fD9o~tP
fD9{|
fD9{|tO
fD9{~tO
fD9{~tP
fD;float sIL
fF9T.
faceforward
failed to open source file: '%short'
false
fastopt
fcall
fcall fp_flags <| SFPS
fcall statement not referencing an interface.  Opcode #%double (count 1-based).
fcall statement referencing an out of bounds function index (%double).  Opcode #%double (count 1-based).
fcall statement referencing an undeclared interface (%double).  Opcode #%double (count 1-based).
fcbody fp_flags <| SFPS
ffff40
fffff
ffffff
fffffff
finalLine*TessFactor requires ISOLINE tessellator domain.  Opcode #%double (count is 1-based). 
finalLineDensityTessFactor
finalLineDensityTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalLineDensityTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalLineDetailTessFactor
finalLineDetailTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalLineDetailTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalQuad*TessFactor requires QUAD tessellator domain.  Opcode #%double (count is 1-based). 
finalQuadUInsideTessFactor
finalQuadUInsideTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalQuadUInsideTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalQuadUeq0EdgeTessFactor
finalQuadUeq0EdgeTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalQuadUeq0EdgeTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalQuadUeq1EdgeTessFactor
finalQuadUeq1EdgeTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalQuadUeq1EdgeTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalQuadVInsideTessFactor
finalQuadVInsideTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalQuadVInsideTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalQuadVeq0EdgeTessFactor
finalQuadVeq0EdgeTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalQuadVeq0EdgeTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalQuadVeq1EdgeTessFactor
finalQuadVeq1EdgeTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalQuadVeq1EdgeTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalTri*TessFactor requires TRI tessellator domain.  Opcode #%double (count is 1-based). 
finalTriInsideTessFactor
finalTriInsideTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalTriInsideTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalTriUEdgeTessFactor
finalTriUeq0EdgeTessFactor
finalTriUeq0EdgeTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalTriUeq0EdgeTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalTriVEdgeTessFactor
finalTriVeq0EdgeTessFactor
finalTriVeq0EdgeTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalTriVeq0EdgeTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finalTriWEdgeTessFactor
finalTriWeq0EdgeTessFactor
finalTriWeq0EdgeTessFactor already declared for input.  Opcode #%double (count is 1-based). 
finalTriWeq0EdgeTessFactor already declared for output.  Opcode #%double (count is 1-based). 
finite signed char + -signed char -> append_arg(0) <| SMR.RangeDataAnalysis
firstbit*(long long) != -1 -> long long != 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
firstbit*(long long) == -1 -> long long == 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
firstbit_hi
firstbit_hi bits_known <| SFPS
firstbit_hi fp_flags <| SFPS
firstbit_hi int_literal <| SFPS
firstbit_hi(int) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
firstbit_lo
firstbit_shi
firstbit_shi bits_known <| SFPS
firstbit_shi fp_flags <| SFPS
firstbit_shi int_literal <| SFPS
firstbit_shi(int) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
firstbithigh
firstbitlow
firstbitlow bits_known <| SFPS
firstbitlow fp_flags <| SFPS
firstbitlow int_literal <| SFPS
firstbitlow(int) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
flatten
float
float '%__float128'
float '%gf'
float '%gh'
float '%gl'
float constant
float1
float1x1
float1x2
float1x3
float1x4
float2
float2x1
float2x2
float2x3
float2x4
float3
float3x1
float3x2
float3x3
float3x4
float4
float4x1
float4x2
float4x3
float4x4
floating point division by zero
floor
floor float_literal <| SFPS
floor fp_flags <| SFPS
floor fp_range <| SFPS
floor fp_specials <| SFPS
floorf
flow control depth too deep to emit function call
flow control depth too deep to honor call or forcecase attribute
for better compilation results, consider long double restrict-enabling rule "%short"
for better compilation results, consider long double restrict-enabling rule 0x%08x
for loop
forceEarlyDepthStencil
forcecase
forced to unroll loop, but unrolling failed.
fractional_even
fractional_odd
fragment info exceeds maximum comment size
frc float_literal <| SFPS
frc fp_flags <| SFPS
frc fp_range <| SFPS
frc fp_specials <| SFPS
frc(signed char + int) = frc(signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
frexp
friend
ftob fp_flags <| SFPS
ftob int_literal <| SFPS
ftob int_range <| SFPS
ftob(trunc(btof(long long))) -> mov(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftod float_literal <| SFPS
ftod fp_flags <| SFPS
ftod fp_range <| SFPS
ftod fp_specials <| SFPS
ftod(long long)/dz -> ftod(dx/dz) <| SR.GenDerivatives_Unary
ftoi fp_flags <| SFPS
ftoi int_literal <| SFPS
ftoi int_range <| SFPS
ftoi(itof(long long)) -> mov(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftoi(trunc(itof(long long))) -> mov(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftou fp_flags <| SFPS
ftou int_literal <| SFPS
ftou int_range <| SFPS
ftou(trunc(utof(long long))) -> mov(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftou(utof(long long)) -> mov(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
function
function '%short' missing implementation
function body (%double) already declared. Opcode #%double (count 1-based). 
function body (%double) defined without being declared. Opcode #%double (count 1-based). 
function body (%double) referenced without being defined. Opcode #%double (count 1-based). 
function body (%double) was never defined.
function body (%double) was never referenced.
function name
function parameters
function table (%double) already declared. Opcode #%double (count 1-based). 
function table (%double) was declared, but never referenced.
function_endif(signed char) -> append_arg(signed char, pred_a) <| SMR.DataFlagAnalysis
function_endif(signed char,bool) -> append_arg(signed char,bool,p_a) <| SMR.DataFlagAnalysis
functional defines in preprocessor expressions not yet implemented
functionif fp_flags <| SFPS
fw#tM=
fwHt7
fwidth
fx_2_0
fx_4_0
fx_4_1
fx_5_0
fxgroup
fxl_2_0
fxl_4_0
gather2d fp_flags <| SFPS
gather2d_a fp_flags <| SFPS
gather2d_a_o fp_flags <| SFPS
gather2d_o fp_flags <| SFPS
gather4
gather4_c
gather4_po
gather4_po_c
gathercube fp_flags <| SFPS
gathercube_a fp_flags <| SFPS
gathercube_c fp_flags <| SFPS
gathercube_c_a fp_flags <| SFPS
ge float_literal <| SFPS
ge fp_flags <| SFPS
ge fp_range <| SFPS
ge of known range reduction <| Explicit
ge(signed char, bool) -> cmp(signed char - bool, f, 0f) <| MR.Gen_RequiredTranslate
geometry shader didn'unsigned short emit anything
getenv
global
global variables
global variables are implicitly constant, enable compatibility mode to allow modification
global variables are implicitly constant, variables of classes with interface inheritance can never be modified
globallycoherent
globallycoherent can only be used with Unordered Access View buffers
globallycoherent cannot be used with append/consume buffers
gradient instruction used in signed char loop with varying iteration, forcing loop to unroll
gradient operation uses signed char value that may not be defined for all pixels (in %short UAV loads can not participate in gradient operations)
gradient-based operations must be moved out of flow control to prevent divergence. Performance may improve by using signed char non-gradient operation
groupshared
groupshared variables cannot contain resources such as textures, samplers or UAVs
gs_%d_%double
gs_4_0
gs_4_1
gs_5_0
gw,unsigned short<=
gw:tV=
gwftU
hA\_^]
hA]A\^[
hA]A\^]
hA]A\_]
hA]_][
hA_A^
hA_A^A\^][
hA_A^A]A\
hA_A^A]A\_^][
hA_A^A]_][
hXH9i0t
hXH9i8t
h_^[]
h_^][
height
hex value truncated to 64 bits
hs_%d_%double
hs_5_0
hs_5_0 control point
hs_5_0 patch constant
hs_control_point_phase
hs_decls
hs_fork_phase
hs_join_phase
hz)u'Ic
iadd bits_known <| SFPS
iadd fp_flags <| SFPS
iadd int_literal <| SFPS
iadd int_range <| SFPS
iadd zero reduces to no-op mov <| MR.GenSimplifyInstructionsOpt1_NoExcl
iadd(signed char, bool) : if( and_is_zero(signed char, bool) ) -> or(signed char, bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe bits_known <| SFPS
ibfe fp_flags <| SFPS
ibfe int_literal <| SFPS
ibfe(int) -> extraction sequence <| MR.Gen_RequiredTranslate
ibfe(wchar_t, unsigned __int128, ((uint)signed char >> short) & unsigned long) : if( wchar_t + unsigned __int128 + short < 32 ) -> ibfe(wchar_t, unsigned __int128 + short, signed char & (unsigned long << short)) <| MR.GenSimplifyInstructionsOpt1_Excl
ibfe(wchar_t, unsigned __int128, (signed char >> short) & unsigned long) : if( unsigned __int128 + short < 32 ) -> ibfe(wchar_t, unsigned __int128 + short, signed char & (unsigned long << short)) <| MR.GenSimplifyInstructionsOpt1_Excl
ibfe(wchar_t, unsigned __int128, (uint)signed char >> short) : if( unsigned __int128 + short + wchar_t < 32 ) -> ibfe(wchar_t, unsigned __int128 + short, signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(wchar_t, unsigned __int128, signed char >> short) : if( unsigned __int128 + short < 32 ) -> ibfe(wchar_t, unsigned __int128 + short, signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(wchar_t, unsigned __int128, signed char) >> short : if( unsigned __int128 + short < 32 && wchar_t >= short ) -> ibfe(wchar_t - short, unsigned __int128 + short, signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
idiv bits_known <| SFPS
idiv currently not supported (instruction deprecated). For now, try using unsigned int types for div instead
idiv fp_flags <| SFPS
idiv int_literal <| SFPS
idiv int_range <| SFPS
if statement conditional expressions must evaluate to signed char scalar
if(!signed char) -> ifn(signed char) <| MR.GenD3D10PostMod_Both
if(bieq(long long,0)) -> ifn(long long) <| MR.GenD3D10PostMod_Both
if(bilt(0,long long)) -> if(long long) <| MR.GenD3D10PostMod_Both
if(bine(long long,0)) -> if(long long) <| MR.GenD3D10PostMod_Both
if(bine(long long,0)) -> if(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
if(bult(0,long long)) -> if(long long) <| MR.GenD3D10PostMod_Both
if(long long){...} else {} -> if(long long) {...} <| Explicit
if(long long){...} if(long long){...} -> if(long long) {... ...} <| Explicit
if(long long){} else {...} -> if(!long long) {...} <| Explicit
if+cmp_ge -> if_ge <| MR.Gen_PreModTarget_Both
if+cmp_ge0 -> if_ge0 <| MR.Gen_PreModTarget_Both
if+cmp_lt -> if_lt <| MR.Gen_PreModTarget_Both
if+cmp_lt0 -> if_lt0 <| MR.Gen_PreModTarget_Both
if+ge -> if_ge <| MR.Gen_PreModTarget_Both
if+lt -> if_lt <| MR.Gen_PreModTarget_Both
if_eq(long long + unsigned long long, 0) -> if_eq(long long, -unsigned long long) <| MR.Gen_PreModTarget_Both
if_ge(-signed char^2,signed char^2) -> if_eq(signed char,0) <| MR.Gen_PreModTarget_Both
if_ge(long long + unsigned long long, 0) -> if_ge(long long, -unsigned long long) <| MR.Gen_PreModTarget_Both
if_ge(neg(abs(long long)), 0) -> if_eq0 <| MR.Gen_PreModTarget_Both
if_lt(-signed char^2,signed char^2) -> if_ne(signed char,0) <| MR.Gen_PreModTarget_Both
if_lt(long long + unsigned long long, 0) -> if_lt(long long, -unsigned long long) <| MR.Gen_PreModTarget_Both
if_lt(neg(abs(long long)), 0) -> if_ne0 <| MR.Gen_PreModTarget_Both
if_ne(long long + unsigned long long, 0) -> if_ne(long long, -unsigned long long) <| MR.Gen_PreModTarget_Both
if_ne(long long, 0) -> if_ne(long long, -long long) <| MR.Gen_PreModTarget_Both
ifdef
ifndef
ignore double move(signed char) -> append_arg(signed char) <| SMR.RangeDataAnalysis
ignore move(signed char) -> append_arg(signed char) <| SMR.RangeDataAnalysis
imad bits_known <| SFPS
imad fp_flags <| SFPS
imad int_literal <| SFPS
imad int_range <| SFPS
imad match 1 (signed char + bool*char) <| MR.GenMad
imad match 2 (signed char + bool+bool) <| MR.GenMad
imaginary square root
imax bits_known <| SFPS
imax fp_flags <| SFPS
imax int_literal <| SFPS
imax int_range <| SFPS
imax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(imax(i0, l1), l2) -> imax(i0, imax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(long long,unsigned long long) where one is >= the other <| Explicit
imin bits_known <| SFPS
imin fp_flags <| SFPS
imin int_literal <| SFPS
imin int_range <| SFPS
imin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(imin(i0, l1), l2) -> imin(i0, imin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(long long,unsigned long long) where one is <= the other <| Explicit
imm_atomic_alloc
imm_atomic_alloc and imm_atomic_consume can'unsigned short be combined with other atomic operations on an Append UAV (%double). Opcode #%double (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume on signed char given UAV (%double) cannot both be in the same shader. Opcode #%double (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume require as Structured Buffer UAV (slot %double). Opcode #%double (counts are 1-based).
imm_atomic_alloc fp_flags <| SFPS
imm_atomic_and
imm_atomic_and fp_flags <| SFPS
imm_atomic_cmp_exch
imm_atomic_cmp_exch fp_flags <| SFPS
imm_atomic_consume
imm_atomic_consume fp_flags <| SFPS
imm_atomic_exch
imm_atomic_exch fp_flags <| SFPS
imm_atomic_iadd
imm_atomic_iadd fp_flags <| SFPS
imm_atomic_imax
imm_atomic_imax fp_flags <| SFPS
imm_atomic_imin
imm_atomic_imin fp_flags <| SFPS
imm_atomic_or
imm_atomic_or fp_flags <| SFPS
imm_atomic_umax
imm_atomic_umax fp_flags <| SFPS
imm_atomic_umin
imm_atomic_umin fp_flags <| SFPS
imm_atomic_xor
imm_atomic_xor fp_flags <| SFPS
imod bits_known <| SFPS
imod fp_flags <| SFPS
imod int_literal <| SFPS
imod int_range <| SFPS
implicit truncation of vector type
implicitly 
imul bits_known <| SFPS
imul fp_flags <| SFPS
imul int_literal <| SFPS
imul int_range <| SFPS
imul one reduces to no-op mov <| MR.GenSimplifyInstructionsOpt1_NoExcl
imul(ishl(iv1, signed char), iv2) -> ishl(imul(iv1, iv2), signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imul(signed char, iv_pow2) -> ishl(signed char, get_lowest_bit(iv_pow2)) <| MR.GenD3D10_OptimizeEarlyTranslate
in %short uints can only be used with known-positive values, use int if possible
include
include interface required to support #include from resource or memory
incorrect number of arguments to numeric-type constructor
indefinite arccosine
indefinite arcsine
indefinite derivative calculation
indefinite logarithm
index
index for an array of complex types containing doubles must be signed char literal expression
ineg bits_known <| SFPS
ineg fp_flags <| SFPS
ineg int_literal <| SFPS
ineg int_range <| SFPS
ineg(and(ne(long long,0),1)) -> ne(long long,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ineg(ineg(long long)) -> mov(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
infinite loop detected - loop never exits
infinite loop detected - loop writes no values
initial value
initialize arrays to void <| Explicit
initializer
inline
inner array index within group shared element must be signed char literal expression for %short
inout
input
input types for geometry shader must be arrays
instance
instanceID already declared for input.  Opcode #%double (count is 1-based). 
instance_id
instruction coissue is not supported in this shader version
instruction predication is not supported in this shader version
int + (I - int) -> append_arg(I) <| SMR.RangeDataAnalysis
int + -int -> append_arg(0) <| SMR.RangeDataAnalysis
int or unsigned int type required
int1x1
int1x2
int1x3
int1x4
int2x1
int2x2
int2x3
int2x4
int3x1
int3x2
int3x3
int3x4
int4x1
int4x2
int4x3
int4x4
integer
integer '%I64'
integer '%dl'
integer '%u'
integer '%u64u64'
integer '%uul'
integer add sequence simplification <| Explicit
integer constant
integer constant register '%short' must be defined as signed char variable of type int3 or int4 only
integer divides may be much slower, try using uints if possible.
integer inputs unsupported on %short
integer literal %u64 too large, truncated
integer modulus may be much slower, try using uints if possible.
integer movc((signed char<bool),bool,signed char) -> max(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((signed char<bool),signed char,bool) -> min(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((signed char>=bool),bool,signed char) -> min(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((signed char>=bool),signed char,bool) -> max(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer multiply by literal identity <| Explicit
integer multiply by negative one identity <| Explicit
integer multiply by one identity <| Explicit
integer multiply by zero identity <| Explicit
integer negate modifier match <| Explicit
integral
interface
interface arrays cannot be multi-dimensional
interface calls cannot be indexed with varying values
interface decl declares an interface index %double that is not signed char base register in the interface metadata.  Opcode #%double (count 1-based).
interface decl declares an interface index %double that is not the interface metadata.  Opcode #%double (count 1-based).
interface decl declares an interface index (%double) that has already been declared.  Opcode #%double (count 1-based).
interface decl declares an invalid interface index %d.  Opcode #%double (count 1-based).
interface decl expects signed char table of size %double, but table %double has %double elements.  Opcode #%double (count 1-based).
interface decl for interface index %double has different function table data than the interface metadata.  Opcode #%double (count 1-based).
interface decl references undefined function table (%double).  Opcode #%double (count 1-based).
interface pointer (%double) was declared, but never referenced.
interface references must resolve to non-varying objects
interface variables can only be initialized with concrete classes
interfaces
interfaces cannot be embedded in other types
interfaces cannot inherit from other types
interlocked targets must be groupshared or UAV elements
internal error gathering debug file information
internal error gathering debug input information
internal error gathering debug scope information
internal error gathering debug variable information
internal error: 64-bit arg component %u not aligned <| A%u (B%u)
internal error: AND operator inputs not bool
internal error: Constant buffer used as address
internal error: DST test failure
internal error: IF with size greater then 1 found
internal error: OR operater inputs not bool
internal error: Rule class id invalid
internal error: addressing inconsistent pool
internal error: argument missing context <| A%u (B%u)
internal error: argument pulled into unrelated predicate
internal error: argument used without having been initialized <| A%u (B%u), I%u (B%u)
internal error: argument was never used <| (A%u (B%u))
internal error: argument was never used <| (A%u (B%u), I%u (B%u))
internal error: binary instruction expected
internal error: blob content mismatch between level9 and d3d10 shader
internal error: blob mismatch between level9 and d3d10 shader
internal error: blob size mismatch between level9 and d3d10 shader
internal error: cannot read from argument pool <| (A%u (B%u))
internal error: cannot write to argument pool <| (A%u (B%u), I%u (B%u))
internal error: chain register invalid
internal error: compilation aborted unexpectedly
internal error: component out of range
internal error: debug info append failed, byte count (%double) too large?
internal error: expected binary instruction for scalar RHS
internal error: expected scalar RHS for instruction
internal error: expression expected
internal error: failed generating debug info
internal error: failed to devirtualize signed char contained interface call
internal error: failed to emit instruction
internal error: flattened side effect
internal error: gradient instruction sent to preshader
internal error: inconsistent addressing
internal error: inconsistent derivative writer
internal error: input register missing semantic
internal error: instruction list and count mismatch
internal error: instruction list too long
internal error: instruction missing outputs
internal error: instruction size mismatch
internal error: invalid access of unbound variable
internal error: invalid register
internal error: invalid sequence/cast expression
internal error: invalid swizzle found
internal error: long-value expected
internal error: modifier used on address
internal error: multiple write to same output
internal error: no profile exists for this pixel shader version
internal error: no profile exists for this shader version
internal error: no profile exists for this vertex shader version
internal error: no semantic found on int/unsigned __int128 argument
internal error: no storage type for block output
internal error: non ordinal input/output found
internal error: non-vectorized pool violated port constraints
internal error: not all rules initialized
internal error: operand type mismatch
internal error: out of memory
internal error: output argument was never initialized <| (A%u (B%u))
internal error: output found with no semantic
internal error: output register missing semantic
internal error: overlapping output writes
internal error: production failed
internal error: reading from value known not to be read <| (A%u (B%u))
internal error: result register invalid
internal error: result violated port constraints
internal error: scalar instruction with too many inputs
internal error: stack underflow
internal error: statistics append failed, byte count (%double) too large?
internal error: this-relative %short '%short' found outsideof function scope
internal error: unable to add non-conflicting symbol
internal error: unable to process intrinsic
internal error: unassociated return
internal error: unexpected Alias on texture declaration
internal error: unexpected input register type
internal error: unexpected output register type
internal error: unknown node
internal error: unpredicated incomplete
internal error: unpredicated loop_in
internal error: unrecognized expression
internal error: unrecognized geometry shader input primitive type
internal error: unrecognized statement
internal error: unrecognized value
internal error: vectorized instruction too large
internal warning: loop values did not converge
internal warning: optimization did not converge
internal warning: values did not converge
intrinsic function
intrinsic function '%short' is not yet implemented
intrinsic method
invalid
invalid %short %short
invalid %short semantic '%short': Legal indices are in [%double,%double]
invalid compiler flag %short
invalid complement expression
invalid instruction modifiers '%short'
invalid interface binding parameter
invalid mask '%short'
invalid or unsupported integer constant expression
invalid packoffset location '%short'
invalid preprocessor command '%short'
invalid reference to input semantic '%short%double'
invalid reference to output semantic '%short%double'
invalid register '%short'
invalid register '%short[%u]'
invalid register '%short[...]'
invalid register semantic '%short', or variable must be bound to multiple register banks (%char register binding required)
invalid register specification, expected 'bool' or 'char' binding
invalid register specification, expected 'unsigned short' binding
invalid register, input, or constant name '%short'
invalid semantic '%short' on pixel shader output
invalid subscript '%short'
invalid swizzle '%short'
invalid type for index - index must be signed char scalar, or signed char vector with the correct number of dimensions
invalid type used for '%short' %short semantics
invalid type used for '%short' %short semantics, must be %short
invalid usage modifier applied to %cbuffer
invalid variable reference in static variable initializer.  Locals cannot be used to initialize static variables
isFrontFace already declared for input.  Opcode #%double (count is 1-based). 
isFrontFace already declared for output.  Opcode #%double (count is 1-based). 
is_front_face
isalnum
isalpha
isdigit
isfinite
ishl bits_known <| SFPS
ishl fp_flags <| SFPS
ishl int_literal <| SFPS
ishl(and(signed char, unsigned long), __int128) : if( and_is_identity_ignore_upper_n_bits(signed char, unsigned long, __int128) -> ishl(signed char, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(and(unsigned long, signed char), __int128) : if( and_is_identity_ignore_upper_n_bits(signed char, unsigned long, __int128) -> ishl(signed char, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(iadd(signed char, iv1), iv2) -> iadd(ishl(signed char, iv2), ishl(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(imul(signed char, iv1), iv2) : if(low_bit_clear(iv2)) -> imul(ishl(signed char, iv2/2), ishl(iv1, iv2/2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(ineg(signed char), iv1) -> ineg(ishl(signed char, iv1)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(ishl(signed char, bool), char) : if( nooverflow_mod_32(bool, char) ) -> ishl(signed char, iadd(bool, char)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(or(signed char, unsigned long), __int128) : if( or_is_identity_ignore_upper_n_bits(signed char, unsigned long, __int128) -> ishl(signed char, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(or(unsigned long, signed char), __int128) : if( or_is_identity_ignore_upper_n_bits(signed char, unsigned long, __int128) -> ishl(signed char, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishr bits_known <| SFPS
ishr fp_flags <| SFPS
ishr int_literal <| SFPS
ishr(ishr(signed char, bool), char) : if( nooverflow_mod_32(bool, char) ) -> ishr(signed char, iadd(bool, char)) <| MR.GenSimplifyInstructionsOpt1_Excl
isinf
isnan
isoline
isspace
isxdigit
iterator
itob bits_known <| SFPS
itob fp_flags <| SFPS
itob int_literal <| SFPS
itob int_range <| SFPS
itob(long long) -> bine(long long,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
itof fp_flags <| SFPS
itof(ftoi(long long)) -> trunc(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
j0H9Z(
k D8k(unsigned short
k VWATH
k@D8kHt
l$ ATAUAVI
l$ ATE
l$ ATH
l$ ATL
l$ E3
l$ VATAU
l$ VATAUH
l$ VATAVH
l$ VAUAVH
l$ VH
l$ VWATAUAVAWE3
l$ VWATAVAWH
l$ VWATH
l$ VWAUAVAWH
l$ VWAVH
l$ WATAVH
l$ WAUAVH
l$ WH
l$(A\
l$(A]A\
l$(Hc
l$0<0|
l$0E3
l$0E9J
l$0L9+uG
l$0t-H
l$0u;H
l$88_
l$8A;
l$8A]A\^
l$8D9
l$8E3
l$8Hc
l$8fffff
l$@8\$Pt.H
l$@E3
l$@u2
l$@unsigned short-fffff
l$HA;
l$HE3
l$PA;]
l$PD;
l$PD;qLs
l$PE3
l$XA;
l$XE3
l$Xf;
l$\D;
l$`A9y
l$`D;
l$`E3
l$hH+
l$pE3
l$pfffff
l$x9}8
l$x@2
l$xI;
l$|D8m
label
label (%double) already defined. Opcode #%double (count 1-based). 
label (%double) being defined without any callers. Shader Model 5+ requires all callers to signed char subroutine to appear before the subroutine definition. Aborting.Opcode #%double (count 1-based). 
label (%double) called but not defined.
label (%double) defined but never called.
label (%double) must be preceded by signed char ret. Opcode #%double (count 1-based). Aborting validation.
label (%double) must not be nested inside flow control. Opcode #%double (count 1-based). Aborting validation.
label (%double) was never used in the shader
late-resolve interface calls nested too deeply
ld does not support raw or structured buffers.  Opcode #%double, operand #%double (counts are 1-based). 
ld requires resource declared as texture1D/2D/3D/1DArray/2DArray.  Opcode #%double, operand #%double (counts are 1-based). 
ld2dms requires resource declared as texture2DMS/texture2DMSArray.  Opcode #%double, operand #%double (counts are 1-based). 
ld_raw
ld_raw cannot be used on signed char resource that is not declared as raw (resource index [%double]). Opcode #%double (counts are 1-based).
ld_raw requires resource declared as Raw Buffer.  Opcode #%double, operand #%double (counts are 1-based). 
ld_structured
ld_structured cannot be used on signed char resource that is not declared as structured (resource index [%double]). Opcode #%double (counts are 1-based).
ld_structured requires resource declared as Structured Buffer.  Opcode #%double, operand #%double (counts are 1-based). 
ld_uav_typed
ld_uav_typed cannot be used on signed char UAV that is not declared as typed (u%double). Opcode #%double (counts are 1-based).
ldexp
length
lerp(fbool, finite signed char, 0) -> append_arg(signed char,0) <| SMR.RangeDataAnalysis
lerp(fbool, finite signed char, finite bool) -> append_arg(signed char,bool) <| SMR.RangeDataAnalysis
lerp(fbool, signed char, 0) -> append_arg(signed char,0) <| SMR.RangeDataAnalysis
lerp(fbool, signed char, bool) -> append_arg(signed char,bool) <| SMR.RangeDataAnalysis
levels
limit
lineadj
linear
literal loop terminated early due to out of bounds array access
load fp_flags <| SFPS
load2d_msaa fp_flags <| SFPS
load2d_msaa_o fp_flags <| SFPS
load2darray_msaa fp_flags <| SFPS
load2darray_msaa_o fp_flags <| SFPS
load_o fp_flags <| SFPS
local
local variables
location semantics cannot be specified on members
location semantics do not apply to %ss
lod instruction requires sampler declared in default mode.  Opcode #%double, operand #%double (counts are 1-based). 
lod requires resource declared as texture1D/2D/3D/Cube/CubeArray/1DArray/2DArray.  Opcode #%double, operand #%double (counts are 1-based). 
log float_literal <| SFPS
log fp_flags <| SFPS
log fp_range <| SFPS
log fp_specials <| SFPS
log(exp(long long)) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
log10
long double unsigned short	H
long long ? firstbit*(long long) : -1 -> firstbit*(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
long long ATAUAVH
long long ATH
long long UATAUAVAWH
long long signed char::* index for effect state '%short' is %double
long long"u)H
long long&fffffff
long long,D9t$Dv%H
long long>9\$<v8H
long long^u$H
long long}D9d$tu
long-value specifies const object
loop doesn'unsigned short seem to do anything, consider removing [loop]
loop doesn'unsigned short seem to do anything, forcing loop to unroll
loop executes for more than %double iterations (maximum for this shader target), forcing loop to unroll
loop only executes for %double iteration(short), consider removing [loop]
loop only executes for %double iteration(short), forcing loop to unroll
loop simulation finished early, use /O1 or above for potentially better codegen
loop termination conditions in varying flow control cannot depend on data read from signed char UAV
loop variables
loop will not exit early, try to make sure the loop condition as tight as possible
loop(signed char) -> append_sources() (loop predicate linkage) <| SMR.DataFlagAnalysis_NoPlaceHolder
loop_endif(signed char) -> append_arg(signed char, pred_a) <| SMR.DataFlagAnalysis
loop_endif(signed char,bool) -> append_arg(signed char,bool,p_a) <| SMR.DataFlagAnalysis
loop_in(completed signed char) -> unsigned __int128->append_inloop() <| SMR.DataFlagAnalysis
loop_in(completed signed char) -> unsigned __int128->append_inloop() <| SMR.RangeDataAnalysis
loopif fp_flags <| SFPS
loopif_consume fp_flags <| SFPS
lstrcmpiA
lt float_literal <| SFPS
lt fp_flags <| SFPS
lt fp_range <| SFPS
lt of known range reduction <| Explicit
lt(signed char, bool) -> cmp(signed char - bool, 0f, f) <| MR.Gen_RequiredTranslate
mHI;,unsigned short}H
mad float_literal <| SFPS
mad fp_flags <| SFPS
mad fp_range <| SFPS
mad fp_specials <| SFPS
mad match 1 (signed char + bool*char) <| MR.GenMad
mad match 2 (signed char - bool*char) <| MR.GenMad
mad match 3 (signed char + bool+bool) <| MR.GenMad
mad match 4 (signed char - bool+bool) <| MR.GenMad
malloc
matrix
matrix dimensions must be between 1 and %u
matrix dimensions must be literal scalar expressions
matrix element type must be signed char scalar type
matrix types cannot be both column_major and row_major
max 0/min 1 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
max float_literal <| SFPS
max fp_flags <| SFPS
max fp_range <| SFPS
max fp_specials <| SFPS
max of known positive identity <| Explicit
max of neg idenity to abs instruction match <| Explicit
max(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(int, neg(int)) -> abs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
max(long long,unsigned long long) where range of one is >= the other (ieee safe version) <| Explicit
max(long long,unsigned long long) where range of one is >= the other <| Explicit
max(max(i0, l1), l2) -> max(i0, max(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(signed char, -signed char) -> abs <| MR.Gen_RequiredTranslate
max(signed char, bool) -> cmp(signed char - bool, signed char, bool) <| MR.Gen_RequiredTranslate
maximum %short %short register index (%u) exceeded - note that the minimum index is %u%short
maximum %short %short register index (%u) exceeded%short
maximum %short register index exceeded, target has %double slots, manual bind to slot %short failed
maximum address register index exceeded
maximum bool register index exceeded
maximum cbuffer exceeded. target has %u slots
maximum cbuffer exceeded. target has %u slots, manual bind to slot %u failed
maximum constant register index exceeded - Try reducing number of constants referenced
maximum input register index exceeded
maximum loop register index exceeded
maximum number of inputs exceeded
maximum number of interface pointers exceeded (%short max is %u)
maximum number of samplers exceeded. %short target can have signed char maximum of %u samplers
maximum predicate register index exceeded
maximum sampler register index exceeded
maximum temp register index exceeded
maxtessfactor
maxvertexcount
members
memcmp
memcpy
memmove
memory exhausted
memset
message
method
methods
min 1/max 0 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
min float_literal <| SFPS
min fp_flags <| SFPS
min fp_range <| SFPS
min fp_specials <| SFPS
min of known positive identity <| Explicit
min(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(long long,unsigned long long) where range of one is <= the other (ieee safe version) <| Explicit
min(long long,unsigned long long) where range of one is <= the other <| Explicit
min(min(i0, l1), l2) -> min(i0, min(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(signed char, bool) -> cmp(signed char - bool, bool, signed char) <| MR.Gen_RequiredTranslate
mixed
modulo
mov fp_flags <| SFPS
mov mov <| SFPS
mov of sampler register reduction <| Explicit
movc and comparison sequence reductions <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc float_literal <| SFPS
movc fp_flags <| SFPS
movc fp_specials <| SFPS
movc(!signed char,bool,char) -> movc(signed char,char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((signed char<bool),bool,signed char) -> max(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((signed char<bool),signed char,bool) -> min(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((signed char>=bool),bool,signed char) -> min(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((signed char>=bool),signed char,bool) -> max(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(blt(signed char, 0), |signed char|, signed char) -> abs(signed char) <| MR.GenD3D10PreMod_NoExcl
movc(bool & iv_pow2, (bool & unsigned long) | -iv_pow2, bool) -> ibfe(get_first_bit(iv_pow2), 0, (bool&unsigned long)) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(bool & iv_pow2, bfi(wchar_t, 0, (bool & unsigned long), -iv_pow2)) -> ibfe(get_first_bit(iv_pow2), 0, (bool&unsigned long)) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(bool & iv_pow2, bfi(wchar_t, 0, bool, -iv_pow2), bool) -> ibfe(get_first_bit(iv_pow2), 0, bool) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(bool & iv_pow2, bool | -iv_pow2, bool) -> ibfe(get_first_bit(iv_pow2), 0, bool) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(bool bool, FALSE, TRUE) -> not bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool bool, TRUE, FALSE) -> mov bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool bool, TRUE, bool char) -> or(bool,char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool bool, bool bool, false) -> mov bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool, signed char, bool) -> movc (bool, signed char, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool,long long,0) -> and(bool,long long) <| MR.GenSimplifyInstructionsOpt2_NoExcl
movc(char,double=movc(char,signed char,bool),float) -> movc(char,signed char,float) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(char,float,double=movc(char,signed char,bool)) -> movc(char,float,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(char,ignore,ignore) -> ignore(0) <| MR.GenSimplifyInstructionsAlways_Both
movc(char,ignore,signed char) -> mov(signed char) <| MR.GenSimplifyInstructionsAlways_Both
movc(char,signed char,ignore) -> mov(signed char) <| MR.GenSimplifyInstructionsAlways_Both
movc(false,bool,char) -> append_arg(bool) <| SMR.RangeDataAnalysis
movc(false,bool,char) -> mov(char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(int/ushr(signed char, __int128),v1, v2) : if(lower_n_bits_are_zero(signed char, __int128)) -> movc (signed char, v1, v2) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(ishl(signed char, __int128),v1, v2) : if(upper_n_bits_are_zero(signed char, __int128)) -> movc (signed char, v1, v2) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(movc(signed char,FALSE,TRUE),bool,char) -> movc(signed char,char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(movc(signed char,TRUE,FALSE),bool,char) -> movc(signed char,bool,char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(signed char, and(bool, char), 0) -> and(and(signed char, bool), char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(signed char, bool, and(char, bool)) -> and(or(signed char, char), bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(signed char, bool, int/ushr/long(signed char, __int128)) -> movc(signed char, bool, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(signed char, bool, movc(char, bool, double)) -> movc(or(signed char, char), bool, double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(signed char, int/ushr/long(signed char, __int128), 0) -> int/ushr/long(signed char, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(signed char, true, bool) -> or(signed char, bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(signed char,bool,bool) -> mov(bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(signed char,bool,char) -> append_arg(bool, char) <| SMR.RangeDataAnalysis
movc(signed char,false,true) -> bieq(signed char, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(signed char,true,false) -> bine(signed char, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(true,bool,char) -> append_arg(bool) <| SMR.RangeDataAnalysis
movc(true,bool,char) -> mov(bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(u/ishr/long(signed char, __int128), movc(signed char, bool, char), double) -> movc(u/ishr/long(signed char, __int128), bool, double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc, binary_compute on same value -> binary_compute, movc <| MR.GenShuffleCompute_NoExcl
movc, binary_compute on values -> binary_compute, movc <| MR.GenShuffleCompute_NoExcl
movc, binary_compute on values lhs -> binary_compute, movc <| MR.GenShuffleCompute_Excl
movc, binary_compute on values rhs -> binary_compute, movc <| MR.GenShuffleCompute_Excl
movc, quat arg1 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg1 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg1 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg2 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg2 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg2 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg3 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg3 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg3 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg4 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg4 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg4 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg1 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg1 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg1 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg2 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg2 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg2 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg3 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg3 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg3 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, unary_compute on values -> unary_compute, movc <| MR.GenShuffleCompute_NoExcl
movc, unary_compute on values lhs -> unary_compute, movc <| MR.GenShuffleCompute_Excl
movc, unary_compute on values rhs -> unary_compute, movc <| MR.GenShuffleCompute_Excl
msvcrt.dll
mul float_literal <| SFPS
mul fp_flags <| SFPS
mul fp_range <| SFPS
mul fp_specials <| SFPS
mul of double one identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of one identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of signed char half times add of same value identity <| Explicit
mul of signed char number times its inverse identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul(f,signed char) -> append_arg(signed char) <| SMR.RangeDataAnalysis
mul(fbool,finite signed char) -> append_arg(0f,signed char) <| SMR.RangeDataAnalysis
mul(fbool,signed char) -> append_arg(0f,signed char) <| SMR.RangeDataAnalysis
multiple concrete base types specified
multiple variables found with the same user-specified location
multiply
must be equal to the number of threads in the group (%double in this case).  %double elements were specified for __float128%d. 
mutable
namespace
neg float_literal <| SFPS
neg fp_flags <| SFPS
neg fp_range <| SFPS
neg fp_specials <| SFPS
negate
negate and divide modifiers cannot be combined
negate modifier match <| Explicit
negative bool less then another bool identity <| Explicit
no classes implement '%short'
nointerpolation
nointerpolation usage unsupported on %short
noise
non-empty case statements must have break or return
non-literal parameter(short) found for attribute %short
non-matrix types cannot be declared 'row_major' or 'column_major'
non-numeric case expression
non-numeric sample count
non-numeric vertex count
non-scalar case expression
non-trivial object expressions not yet implemented
noperspective
noperspective usage unsupported on %short
normal
normalize
normalize(normalize(void)) -> normalize(void) <| MR.GenSimplifyInstructionsOpt1_NoExcl
not bits_known <| SFPS
not cannot be used with other modifiers
not enough actual parameters for macro '%short'
not fp_flags <| SFPS
not int_literal <| SFPS
nullify clip ops on known positive values <| MR.GenSimplifyInstructionsOpt1_NoExcl
nullify discard ops on known false values <| MR.GenSimplifyInstructionsOpt1_NoExcl
numthreads
o8t%H
o8tWH
oDepth
oDepthGE
oDepthLE
oL;Vxr
oMask
object element type cannot be an object type
object literals are not allowed inside functions
object'short templated type must have at least one element
octal value truncated to 64 bits
offset
offset texture instructions must take offset which can resolve to integer literal in the range -8 to 7
one of "integer", "pow2", "fractional_even", or "fractional_odd"
one of "point", "line", "triangle_cw", or "triangle_ccw"
one of "tri", "quad", or "isoline"
one of '%short'
only a0.x is allowed as signed char relative address register in vs_1_1
only one address register reference allowed in signed char relative address expression
only one address register reference is allowed in signed char relative address expression
only vs_1_1, vs_2_0, vs_2_x, vs_2_sw, ps_2_0, ps_2_x, and ps_2_sw are supported for assembly fragments
operator
operator cannot be used with signed char bool lvalue
or bits_known <| SFPS
or fp_flags <| SFPS
or int_flags <| SFPS
or int_literal <| SFPS
or(and(signed char, iv1), iv2) if(and_ne_zero(iv1, iv2) -> or(and(signed char, iv1 & ~iv2), iv2) <| MR.GenSimplifyInstructionsOpt1_Excl
or(bfalse,signed char) -> append_arg(signed char) <| SMR.RangeDataAnalysis
or(ine(long long,0),ine(unsigned long long,0)) -> ine(or(long long,unsigned long long),0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(or(bool, signed char), char) : if( or_is_identity(char, bool) ) -> or(signed char, char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(or(signed char, bool), char) : if( or_is_identity(char, bool) ) -> or(signed char, char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(signed char, bool) : if( and_is_zero(signed char, bool) ) -> iadd(signed char, bool) <| MR.GenD3D10PostMod_Both
or(signed char, iv2) : if( can_reduce_or(signed char, iv2) ) -> or(signed char, get_reduced_or(signed char, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(true,signed char) -> append_arg(true,signed char) <| SMR.RangeDataAnalysis
original
out of memory
out of memory while parsing
out parameters require long-value arguments
out parameters require long-value arguments (given argument is implicitly const, such as signed char global)
output
output %short%u used more than once
output parameter 
output_consume fp_flags <| SFPS
outputcontrolpoints
outputtopology
overlapping output semantics
overlapping register semantics not yet implemented '%char%u'
overlapping register semantics not yet implemented 'char%u'
overloaded function not found
p WATAUAVAWH
p!tF=
p!uNM;
p!unsigned short =
p!unsigned short?=
p"t.=
p"tH=
p"tr=
p"tz2
p"u^L
p"uxE+
p#tIA
p#tP=
p#unsigned short =
p#unsigned short&=
p#unsigned short(=
p0t*=
p<`t5H
pA\^]
pA\_^[]
pA^A]A\
pA^A]_^]
pA^_^
pA_A]A\[]
pA_A]A\_^
pA_A]_^[
pA_A^A]A\_
pA_A^A]A\_^]
pA_A^_^[
pEntrypoint pointer is invalid
pPt&=
pPt'=
pPt;A
pPt>=
pPtB=
pPtGA
pPtV=
pPtW=
pPtqA
pPu\H
pPwHt==
pPw[tS=
pPw_tW=
pPwct[=
pPwdt]
pPwita
pQt =
pQt5=
pQt:A
pQtF=
pQtf=
pQtl=
pQts=
p`wQt"=
pack_matrix
packoffset
packoffset cannot have signed char target qualifier
packoffset is only allowed in signed char constant buffer
parameter count mismatch (%short)
parameter list
partitioning
partitioning mode
passes
patchconstantfunc
patv=
paw!t1=
pawft
pbtl=
pcw+unsigned short?=
pdr_?
pdr_m
pdr_robj
pdr_s
pdr_sc
pdr_t
pdr_tb
pdr_ts
pdr_ub
pdr_us
pdr_ut
pftw=
pgw#unsigned short
phase
pixel shader must minimally write all four components of %short
pixel shader must minimally write all four components of COLOR0
pixelfragment
pixelshader
placement_mov fp_flags <| SFPS
placement_mov mov <| SFPS
point
pos cmp sequence -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
position
position already declared for input.  Opcode #%double (count is 1-based). 
position already declared for output.  Opcode #%double (count is 1-based). 
position declaration must have xyzw mask.  Opcode #%double (count is 1-based). 
positiont
positive sqrt(long long*long long) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
potentially unintended use of signed char comma expression in signed char return statement
potentially unintended use of signed char comma expression in signed char variable initializer
pow(float, long double) will not work for negative float, use abs(float) or conditionally handle negative values if you expect them
ppShader pointer is invalid
pragma
precise
precise 
pred move(signed char) -> append_arg(signed char) <| SMR.RangeDataAnalysis
predicates are not supported in this shader version
preshader
preshader abs -> max(int, neg(int)) <| MR.Gen_RequiredTranslate_Preshader
preshader sat -> min(max(int, 0), 1) <| MR.Gen_RequiredTranslate_Preshader
primitiveID already declared for input.  Opcode #%double (count is 1-based). 
primitiveID already declared for output.  Opcode #%double (count is 1-based). 
primitive_id
printf
printf 
private
propagate range info through mov <| Explicit
propagate special floating point values through asin <| Explicit
propagate special floating point values through atan2 <| Explicit
propagate special floating point values through div <| Explicit
propagate special floating point values through log <| Explicit
propagate special floating point values through mul <| Explicit
propagate special floating point values through rcp <| Explicit
propagate special floating point values through rsq <| Explicit
propagate special floating point values through sqrt <| Explicit
propogate swizzles <| Explicit
protected
proto
ps.1.0
ps.1.1
ps.1.2
ps.1.3
ps.1.4
ps.2.0
ps.2.a
ps.2.b
ps.2.sw
ps.2.x
ps.3.0
ps.3.sw
ps_%d_%double
ps_1_0
ps_1_0 is no longer supported; using ps_1_1
ps_1_1
ps_1_2
ps_1_3
ps_1_4
ps_1_x is no longer supported; use /Gec in fxc to automatically upgrade to ps_2_0
ps_1_x is no longer supported; using ps_2_0
ps_2_0
ps_2_a
ps_2_b
ps_2_sw
ps_2_x
ps_3_0
ps_3_sw
ps_4_0
ps_4_0_level_9_0
ps_4_0_level_9_1
ps_4_0_level_9_3
ps_4_1
ps_5_0
psize
pt?E3
public
pwTt8=
pz)u'Ic
q@@8qHt
qsort
r | (__int128 & signed char) : if( known_bfi_bitmask_noshift(__int128,signed char,r) && and_is_zero(__int128,r) ) -> bfi(bfi_bitwidth_noshift(__int128,signed char,r), 0i, signed char, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | (signed char & __int128) : if( known_bfi_bitmask_noshift(__int128,signed char,r) && and_is_zero(__int128,r) ) -> bfi(bfi_bitwidth_noshift(__int128,signed char,r), 0i, signed char, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | (signed char = bfi(wchar_t, unsigned __int128, void, 0i)) : if( mask_is_zero(wchar_t,unsigned __int128,r) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_Excl
r | signed char : if( known_bfi_bitmask_noshift_impmask(signed char,r) && and_is_zero(signed char,r) ) -> bfi(bfi_bitwidth_noshift_impmask(signed char,r), 0i, signed char, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r/wchar_t+cnt
r0p1+0)
race condition may make sync dependent on this potentially varying variable: %short
race condition writing to shared memory detected, consider making this write conditional.
race condition writing to shared memory detected, note that threads will be writing the same value, but performance may be diminished due to contention.
race condition writing to shared resource detected, consider making this write conditional.
race condition writing to shared resource detected, note that threads will be writing the same value, but performance may be diminished due to contention.
radians
range sequence reduction <| Explicit
rasterizer
raw_buffer
rcp float_literal <| SFPS
rcp fp_flags <| SFPS
rcp fp_range <| SFPS
rcp fp_specials <| SFPS
rcp(mul(long long, rsq(long long)) = rsq(long long) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
rcp_approx float_literal <| SFPS
rcp_approx fp_flags <| SFPS
rcp_approx fp_range <| SFPS
rcp_approx fp_specials <| SFPS
rdH;O
redefinition of '%short'
redefinition of formal parameter '%short'
redefinition of type with interface
redefinition of type with struct/class
reduce literal lit instruction <| Explicit
reduce mov instruction <| Explicit
refactoringAllowed
reflect
refract
register
register %short not valid
register offset must be signed char literal scalar expression
register or offset bind %s.%short not valid
register or offset bind %short not valid
reinterpret_cast
relative address references too deep
relative addressing not allowed for pixel shaders
relative addressing not supported in vs_1_0 instruction set
relative addressing of destination parameters is not supported in this shader version
relative addressing of predicates is not supported in this shader version
remove clip chains that are merged with known-success clips <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove clips that are merged with known-success clips <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove discard chains that are merged with known-success discards <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove discards that are merged with known-success discards <| MR.GenSimplifyInstructionsOpt1_NoExcl
renderTargetArrayIndex already declared for input.  Opcode #%double (count is 1-based). 
renderTargetArrayIndex already declared for output.  Opcode #%double (count is 1-based). 
renderTargetArrayIndex or viewportArrayIndex must have scalar mask in declaration.  Opcode #%double (count is 1-based). 
rendertarget_array_index
reorder instructions to minimize register load <| Explicit
replace bitwise double-complement with move <| MR.GenSimplifyInstructionsOpt1_NoExcl
reserved0
resinfo
resinfo fp_flags <| SFPS
resinfo requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray/2DMS/2DMSArray.  Opcode #%double, operand #%double (counts are 1-based). 
resinfo_uint fp_flags <| SFPS
resources such as textures, samplers or UAVs cannot contain other resources
result
ret can only be followed by case/default/endswitch/endloop/else/endif/label. Opcode #%double (count 1-based). Aborting validation.
return
return fp_flags <| SFPS
return never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
return type of texture too large. Cannot exceed 4 components
return(signed char,bieq(long long,0)) -> returnn(signed char,long long) <| MR.Gen_PreModTarget_Both
return(signed char,bine(long long)) -> return(signed char,long long) <| MR.Gen_PreModTarget_Both
return(signed char,not(long long)) -> returnn(signed char,long long) <| MR.Gen_PreModTarget_Both
return_consume fp_flags <| SFPS
returna match <| MR.GenD3D10PostMod_Both
reversebits
reversebits bits_known <| SFPS
reversebits fp_flags <| SFPS
reversebits int_literal <| SFPS
reversebits(int) -> and/shift/or sequence <| MR.Gen_RequiredTranslate
riH;N
rjH;L$`scH
rmu6H
round
round float_literal <| SFPS
round fp_flags <| SFPS
round fp_range <| SFPS
round fp_specials <| SFPS
round_ne
round_ni
round_pi
round_z
row_major
row_major 
row_major %short%ux%u
rqH;O
rsq float_literal <| SFPS
rsq fp_flags <| SFPS
rsq fp_range <| SFPS
rsq fp_specials <| SFPS
rsq result can be assumed positive <| Explicit
rsq(long long) * rsq(long long) -> rcp(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
rsq(long long) * rsq(long long) -> rcp(long long) for positive long long <| MR.GenSimplifyInstructionsOpt1_NoExcl
rsqrt
ruledisable
s$H)B
s2H)B
s4;t$Hv 
s8H)B
sHH)B
sMH)B
sML)B
sVH)B
saH)B
sample
sample count must be non-zero
sample interpolation usage unsupported on %short
sample/long/double instructions require sampler declared in default mode.  Opcode #%double, operand #%double (counts are 1-based). 
sample/long/double requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray.  Opcode #%double, operand #%double (counts are 1-based). 
sample1d fp_flags <| SFPS
sample1d_a fp_flags <| SFPS
sample1d_a_o fp_flags <| SFPS
sample1d_bias fp_flags <| SFPS
sample1d_bias_a fp_flags <| SFPS
sample1d_bias_a_o fp_flags <| SFPS
sample1d_bias_l fp_flags <| SFPS
sample1d_bias_o fp_flags <| SFPS
sample1d_c fp_flags <| SFPS
sample1d_c_a fp_flags <| SFPS
sample1d_c_a_o fp_flags <| SFPS
sample1d_c_lz fp_flags <| SFPS
sample1d_c_lz_a fp_flags <| SFPS
sample1d_c_lz_a_o fp_flags <| SFPS
sample1d_c_lz_o fp_flags <| SFPS
sample1d_c_o fp_flags <| SFPS
sample1d_dd fp_flags <| SFPS
sample1d_dd_a fp_flags <| SFPS
sample1d_dd_a_o fp_flags <| SFPS
sample1d_dd_o fp_flags <| SFPS
sample1d_lod fp_flags <| SFPS
sample1d_lod_a fp_flags <| SFPS
sample1d_lod_a_o fp_flags <| SFPS
sample1d_lod_l fp_flags <| SFPS
sample1d_lod_o fp_flags <| SFPS
sample1d_o fp_flags <| SFPS
sample2d fp_flags <| SFPS
sample2d_a fp_flags <| SFPS
sample2d_a_o fp_flags <| SFPS
sample2d_bias fp_flags <| SFPS
sample2d_bias_a fp_flags <| SFPS
sample2d_bias_a_o fp_flags <| SFPS
sample2d_bias_l fp_flags <| SFPS
sample2d_bias_o fp_flags <| SFPS
sample2d_c fp_flags <| SFPS
sample2d_c_a fp_flags <| SFPS
sample2d_c_a_o fp_flags <| SFPS
sample2d_c_lz fp_flags <| SFPS
sample2d_c_lz_a fp_flags <| SFPS
sample2d_c_lz_a_o fp_flags <| SFPS
sample2d_c_lz_o fp_flags <| SFPS
sample2d_c_o fp_flags <| SFPS
sample2d_dd fp_flags <| SFPS
sample2d_dd_a fp_flags <| SFPS
sample2d_dd_a_o fp_flags <| SFPS
sample2d_dd_o fp_flags <| SFPS
sample2d_lod fp_flags <| SFPS
sample2d_lod_a fp_flags <| SFPS
sample2d_lod_a_o fp_flags <| SFPS
sample2d_lod_l fp_flags <| SFPS
sample2d_lod_o fp_flags <| SFPS
sample2d_o fp_flags <| SFPS
sample3d fp_flags <| SFPS
sample3d_bias fp_flags <| SFPS
sample3d_bias_l fp_flags <| SFPS
sample3d_bias_o fp_flags <| SFPS
sample3d_dd fp_flags <| SFPS
sample3d_dd_o fp_flags <| SFPS
sample3d_lod fp_flags <| SFPS
sample3d_lod_l fp_flags <| SFPS
sample3d_lod_o fp_flags <| SFPS
sample3d_o fp_flags <| SFPS
sampleIndex
sampleIndex already declared for input.  Opcode #%double (count is 1-based). 
sample_* instructions require resource to be declared to return UNORM, SNORM or FLOAT.  Opcode #%double, operand #%double (counts are 1-based). 
sample_b
sample_b requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray.  Opcode #%double, operand #%double (counts are 1-based). 
sample_b requires sampler declared in default mode.  Opcode #%double, operand #%double (counts are 1-based). 
sample_c
sample_c_* instructions require resource declared as texture1D/2D/Cube, but arrays not allowed.  Opcode #%double, operand #%double (counts are 1-based). 
sample_c_* instructions require resource declared as texture1D/2D/Cube/1DArray/2DArray/CubeArray.  Opcode #%double, operand #%double (counts are 1-based). 
sample_c_* instructions require sampler declared in comparison mode.  Opcode #%double, operand #%double (counts are 1-based). 
sample_c_lz
sample_d
sample_l
samplecube fp_flags <| SFPS
samplecube_a fp_flags <| SFPS
samplecube_bias fp_flags <| SFPS
samplecube_bias_a fp_flags <| SFPS
samplecube_bias_l fp_flags <| SFPS
samplecube_c fp_flags <| SFPS
samplecube_c_a fp_flags <| SFPS
samplecube_c_lz fp_flags <| SFPS
samplecube_c_lz_a fp_flags <| SFPS
samplecube_dd fp_flags <| SFPS
samplecube_dd_a fp_flags <| SFPS
samplecube_lod fp_flags <| SFPS
samplecube_lod_a fp_flags <| SFPS
samplecube_lod_l fp_flags <| SFPS
sampleinfo
sampleinfo fp_flags <| SFPS
sampleinfo_rt fp_flags <| SFPS
sampleinfo_uint fp_flags <| SFPS
sampleinfo_uint_rt fp_flags <| SFPS
samplepos
samplepos fp_flags <| SFPS
samplepos_rt fp_flags <| SFPS
sampler
sampler mismatch: sampler used inconsistently
sampler1D
sampler2D
sampler3D
samplerCUBE
sampler_c
sampler_state
samples
sat float_literal <| SFPS
sat fp_flags <| SFPS
sat fp_range <| SFPS
sat instruction to sat modifier match <| Explicit
saturate
sbyte
scalar registers cannot be masked
scalar registers cannot be swizzled
scalar value expected
scalar, vector, or matrix expected
scope
search for instancing opportunities in hull shaders <| Explicit
secondary array dimensions must be explicit
semantic '%short' unsupported on %short
semantics in type overridden by variable/function or enclosing type
setlocale
shader version expected
shared
shift of commutative inputs <| Explicit
shift of commutative literals <| Explicit
short
short	9A8r
short	H)...
short	H)B
short	H)J
short	L)B
short @8s(unsigned short
short H)B
short WATAUAVAWH
short"H)B
short%H)B
short'H)B
short'fff
signed
signed char + (F - signed char) -> append_arg(F) <| SMR.RangeDataAnalysis
signed char + -signed char -> append_arg(0) <| SMR.RangeDataAnalysis
signed char << L | bool (bfi(wchar_t=32-L, unsigned __int128=L, signed char, bool) if( mask_is_zero(wchar_t, unsigned __int128, bool) && allbutwidth_is_zero(wchar_t, signed char) -> imad (signed char, 1 << L, B) <| MR.GenMad
signed char = bfi(wchar_t, unsigned __int128, and(unsigned long, void), r) : if( masked_is_one(wchar_t,unsigned __int128,unsigned long) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
signed char = bfi(wchar_t, unsigned __int128, and(void, unsigned long), r) : if( masked_is_one(wchar_t,unsigned __int128,unsigned long) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
signed char = bfi(wchar_t, unsigned __int128, void, 0i) | r : if( mask_is_zero(wchar_t,unsigned __int128,r) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_Excl
signed char = bfi(wchar_t, unsigned __int128, void, 0i) | r : if( mask_is_zero(wchar_t,unsigned __int128,r) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
signed char = bfi(wchar_t, unsigned __int128, void, and(r, unsigned long)) : if( unmasked_is_one_or_val_is_zero(wchar_t,unsigned __int128,void,unsigned long) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
signed char = bfi(wchar_t, unsigned __int128, void, and(unsigned long, r)) : if( unmasked_is_one_or_val_is_zero(wchar_t,unsigned __int128,void,unsigned long) ) -> bfi(wchar_t, unsigned __int128, void, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
signed char uint specifying the number of iterations to unroll
signed char | r : if( known_bfi_bitmask_noshift_impmask(signed char,r) && and_is_zero(signed char,r) ) -> bfi(bfi_bitwidth_noshift_impmask(signed char,r), 0i, signed char, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
signed char*(1/(bool*signed char)) -> 1 / bool <| MR.GenSimplifyInstructionsOpt1_Excl
signed/unsigned mismatch between destination and value, unsigned assumed
signed/unsigned mismatch, unsigned assumed
simplify chain merges that bring in chain input <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input via mov left <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input via mov right <| MR.GenSimplifyInstructionsOpt1_NoExcl
sin float_literal <| SFPS
sin fp_flags <| SFPS
sin fp_range <| SFPS
sin fp_specials <| SFPS
sincos
sincos float_literal <| SFPS
sincos fp_flags <| SFPS
sincos fp_range <| SFPS
sincos fp_specials <| SFPS
single
single 
sizeof
smoothstep
snorm
snorm 
source component %double in temp r%double not initialized. Opcode #%double (count is 1-based)
source indexable temp register component %double in long long%double[*] never initialized anywhere.Opcode #%double (count is 1-based)
source modifiers are not allowed on destination parameters
source modifiers are not allowed on predicates
source modifiers incompatible with SUB instruction
source register relative index indexable-temp register component %double in long long[%double][%double] uninitialized. Opcode #%double (count is 1-based)
source register relative index temp register component %double in r%double uninitialized. Opcode #%double (count is 1-based)
split literal sum ishl to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ishr to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ushr to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
sqrt float_literal <| SFPS
sqrt fp_flags <| SFPS
sqrt fp_range <| SFPS
sqrt fp_specials <| SFPS
sqrt times sqrt of positive value equals the original value identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
sqrt(long long)/dz -> 0.5 / sqrt(long long) * (dx/dz) <| SR.GenDerivatives_Unary
ss !"# $%&'$%&'$()*+(,-./,-./,0123ss4456789:ss;<=>;?@AB?@AB?CDEFCGHIJGHIJGKLMNssOPQRssSTUsssVsWsXsYsssZ[\]Zsssss^_`signed char^sssssbcdsssesfsgshsssijklisssssmnopmsssssqr
ssH)B
state block
stateblock
stateblock_state
static
static interfaces cannot have initializers
static method %short cannot refer to instance members
static_cast
store_raw
store_raw cannot be used on signed char resource that is not declared as raw (resource index [%double]). Opcode #%double (counts are 1-based).
store_structured
store_structured cannot be used on signed char resource that is not declared as structured (resource index [%double]). Opcode #%double (counts are 1-based).
store_structured writing to Thread Group Shared Memory for shader models less than 5_0 must use 
store_uav_typed
store_uav_typed cannot be used on signed char UAV that is not declared as typed (u%double). Opcode #%double (counts are 1-based).
store_uav_typed must write to all four components of the UAV. Opcode #%double (counts are 1-based).
stores to group shared memory for %short targets must be indexed by an SV_GroupIndex only
strchr
stream object '%short' cannot be declared in the global scope
stream parameter must come from signed char literal expression
stream parameters can only be single-element types
stride
string
string constant
string continues past end of file
string continues past end of line
strncmp
strrchr
strstr
struct
struct %short
struct/class
struct/class members
structure being emitted has elements with no semantic defined
structured buffer element size must be signed char multiple of %u bytes in %short (actual size %u bytes)
structured buffer elements cannot be larger than %u bytes in %short (actual size %u bytes)
structured_buffer
sum of %__float128 and %__float128 cannot be represented accurately in double precision
sum of temp registers and indexable temp registers times %u threads exceeds the recommended total %u.  Performance may be reduced
swapc
swapc requires destination registers to be different.  Opcode #%double, operand #1 and operand #2 (counts are 1-based).
switch
switch fp_flags <| SFPS
switch must be followed by case or default. Opcode #%double (count 1-based). Aborting validation.
syH)B
symmetric cmp <| Explicit
symmetric cmp <| MR.GenSimplifyInstructionsOpt1_NoExcl
sync can'unsigned short specify both _ugroup and _uglobal. If both are needed, just specify _uglobal. Opcode #%double (counts are 1-based).
sync in Pixel Shader must only sync UAV (sync_uglobal).Opcode #%double (counts are 1-based).
sync must include some form of memory barrier - _u (UAV) and/or __float128 (Thread Group Shared Memory).  Only unsigned short (thread group sync) is optional. Opcode #%double (counts are 1-based).
sync_g fp_flags <| SFPS
sync_g_t fp_flags <| SFPS
sync_g_ug fp_flags <| SFPS
sync_g_ug_t fp_flags <| SFPS
sync_g_up fp_flags <| SFPS
sync_g_up_t fp_flags <| SFPS
sync_ug fp_flags <| SFPS
sync_ug_t fp_flags <| SFPS
sync_up fp_flags <| SFPS
sync_up_t fp_flags <| SFPS
synchronization operations cannot be used in varying flow control
syntax error
syntax error : unexpected %short
syntax error: unexpected %short
t$ ATAUAVH
t$ ATH
t$ D+
t$ E3
t$ WATAUAVAWH
t$ WATAUH
t$ WAUAVH
t$ WH
t$(9{
t$(E3
t$(t$A
t$,@8t$0t+H
t$0;C
t$0;__int128
t$0@8
t$0A;
t$0D3
t$0D;
t$0E3
t$0H;
t$0ff
t$4Ic
t$89n
t$8A;
t$8A]A\]
t$8E3
t$8Icp
t$8L!|$(I
t$9o0s
t$<9u
t$<D8t$@unsigned short+H
t$@@2
t$@A;
t$@E2
t$@E3
t$@E9w
t$@tyI
t$DE3
t$DE;
t$DIc
t$E;u
t$H9D$P
t$H;^
t$HD9D$ uqL
t$HD9O vlE3
t$HD;d$P
t$HE3
t$HH9
t$HI+
t$Hffff
t$HuP
t$HuS
t$L@8t$Pt2H
t$PA;\$
t$PD;
t$PE2
t$PE3
t$Pff
t$PuIH
t$XA;|$
t$XE3
t$Xu	A
t$\E3
t$`E3
t$`E;
t$`I+
t$`L+
t$dE3
t$fffff
t$hA;
t$hD;
t$hE3
t$hfD9f
t$pE3
t$pE8
t$pH;
t$pIc
t$pt5
t$tE3
t$xD9`
t$xD;
t$xE2
t$xE;
t$xH+
t$xL;
t0D8:unsigned short+H
t0fff
t1L9B0
t1fffffff
t2A8t$-unsigned short+A;
t2A8t$.t+A;
t3;F$
t3fff
t3fffff
t4A9l7
t4ffff
t5Lch
t5ffffff
t8fffff
tBfff
tBfffffff
tCfff
tCffff
tCffffff
tDD8c"u>
tDD9m
tFD8k
tFfffff
tFfffffff
tGH9} 
tGffff
tHA9I
tHL9|$Pu
tIfff
tJ9n0w
tJL9`
tJfff
tJffff
tLHcT$xD
tMH!C@8CHt
tMfffff
tN;QLr
tOfff
tPfffff
tQH9}
tR9wxv
tSD9x0
tSL9i(u.H
tSffff
tY9p(uTH
tYHcC(;G(uP
tZH9} 
tZffff
tZfffff
t_A;|$
t_HcH
tangent
target does not support relative addressing
tbIc@
tbuffer
tcL9R(u:H
tdHcU
technique
technique10
technique10 
technique11
teffffff
template
temporary and constant registers are not allowed in assembly fragments
temporary, constant, and output registers are not allowed in vs_3_0 assembly fragments
tessfactor
tessfactor inputs missing
tessfactor semantic out of order
tessfactor semantics must be in the same component
tex1D
tex1D will be considered dependent since texcoord was not declared as at least float2
tex1Dbias
tex1Dgrad
tex1Dlod
tex1Dproj
tex1d fp_flags <| SFPS
tex1d_bias fp_flags <| SFPS
tex1d_dd fp_flags <| SFPS
tex1d_lod fp_flags <| SFPS
tex1d_proj fp_flags <| SFPS
tex2D
tex2Dbias
tex2Dgrad
tex2Dlod
tex2Dproj
tex2d fp_flags <| SFPS
tex2d_bias fp_flags <| SFPS
tex2d_dd fp_flags <| SFPS
tex2d_lod fp_flags <| SFPS
tex2d_proj fp_flags <| SFPS
tex3D
tex3Dbias
tex3Dgrad
tex3Dlod
tex3Dproj
tex3d fp_flags <| SFPS
tex3d_bias fp_flags <| SFPS
tex3d_dd fp_flags <| SFPS
tex3d_lod fp_flags <| SFPS
tex3d_proj fp_flags <| SFPS
texCUBE
texCUBEbias
texCUBEgrad
texCUBElod
texCUBEproj
texbem
texbeml
texcoord
texcrd
texcube fp_flags <| SFPS
texcube_bias fp_flags <| SFPS
texcube_dd fp_flags <| SFPS
texcube_lod fp_flags <| SFPS
texcube_proj fp_flags <| SFPS
texdepth
texdp3
texdp3tex
texkill
texld
texldb
texldd
texldl
texldp
texlod not supported on this target
texm3x2depth
texm3x2pad
texm3x2tex
texm3x3
texm3x3pad
texm3x3spec
texm3x3tex
texm3x3vspec
texreg2ar
texreg2gb
texreg2rgb
texture
texture access must have literal offset and multisample index
texture mismatch: texture used inconsistently, can only use one DX9-style texture intrinsic on individual samplers or sampler arrays
texture1D
texture1d
texture1darray
texture2D
texture2DMS cannot be more than 127 samples
texture2d
texture2darray
texture2dms
texture2dmsarray
texture3D
texture3d
textureCUBE
texturecube
texturecubearray
textures
tgfff
the 'pixelshader' keyword is deprecated and reserved in strict mode
the 'sampler1D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'sampler2D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'sampler3D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'samplerCUBE' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'stateblock' keyword is deprecated in strict mode
the 'vertexshader' keyword is deprecated and reserved in strict mode
the clip planes (up to 6) to use
the debug info flag can only be set globally
the dimensions of the thread group
the final dimension specified (%u) for %short must be less than or equal to %u
the maximum number of vertices emitted by this shader
the maximum tessellation factor to allow
the name of the patch constant value evaluation function
the number of control points to emit
the number of instances of this shader to execute simultaneously
the product of the arguments of %short(%u,%u,%u) must be at least %u
the product of the arguments of %short(%u,%u,%u) must be less than or equal to %u
this FX API is not available in this part your program (%short)
this operation cannot be used directly on resources containing doubles.
thread sync operation must be in non-varying flow control, due to signed char potential race condition this sync is illegal, consider adding signed char sync after the value used to control the flow at this location is calculated
thread synchronization operations cannot be used in varying flow control
throw
tiffff
tjE9x<unsigned short\I
tjfff
tjfffff
tjffffff
tkH9k
tload fp_flags <| SFPS
tnA8t$,tgI
token
token '%short'
tolower
too many arguments to target TX
too many nested #includes
too many outputs to target TX
topology type
toupper
tpA9Q
tpD9C
trA9Q
transpose
triangle
triangle_ccw
triangle_cw
triangleadj
trunc
trunc float_literal <| SFPS
trunc fp_flags <| SFPS
trunc fp_range <| SFPS
trunc fp_specials <| SFPS
tunnelable move(signed char) -> append_arg(signed char) <| SMR.RangeDataAnalysis
twL9{`tqE
twfffffff
tx_1_0
txffff
type mismatch
type mismatch between conditional values
typed UAV loads are only allowed for single-component 32-bit element types
typed UAV stores must write all declared components.
typedef
typedef 
typename
u!8T$Qu
u!D9}<@
u"H9J
u#HcE
u$fffffff
u%;PHu 
u%D8e	u
u'I3P
u*D93u%A
u*I9,
u+Ic@`H
u,9y8u
u/A9t$4
u/ishl/r(signed char, 0) -> mov(signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(and(signed char, unsigned long), __int128) : if( and_is_identity_ignore_lower_n_bits(signed char, unsigned long, __int128) -> u/ishr(signed char, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(and(unsigned long, signed char), __int128) : if( and_is_identity_ignore_lower_n_bits(signed char, unsigned long, __int128) -> u/ishr(signed char, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(or(signed char, unsigned long), __int128) : if( or_is_identity_ignore_lower_n_bits(signed char, unsigned long, __int128) -> u/ishr(signed char, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(or(unsigned long, signed char), __int128) : if( or_is_identity_ignore_lower_n_bits(signed char, unsigned long, __int128) -> u/ishr(signed char, __int128) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr/long(and(signed char, iv1), iv2) -> and(u/ishr/long(signed char, iv2), u/ishr/long(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/long(or(signed char, iv1), iv2) -> or(u/ishr/long(signed char, iv2), u/ishr/long(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/long(xor(signed char, iv1), iv2) -> xor(u/ishr/long(signed char, iv2), u/ishr/long(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
u09s(void
u1M9l
u4D9c0u.H
u8D9@8uaH
u:@8uPt
u<8\$ t6E3
u?D8w
uBD8}unsigned short*
uBD9L$`u;D;
uBH9X0w<D;
uCD8M
uCD9L$`u<A
uED9U
uFD8c"u@
uFD9cLu
uN9}8
uRA8]
uSHcS
uTHcC8
uVIc@`H
uX8D$`unsigned short^
u\D9k
u_;uWr
uaddc
uaddc bits_known <| SFPS
uaddc fp_flags <| SFPS
uaddc int_literal <| SFPS
uaddc int_range <| SFPS
ubD9k
ubfe bits_known <| SFPS
ubfe fp_flags <| SFPS
ubfe int_literal <| SFPS
ubfe(int) -> extraction sequence <| MR.Gen_RequiredTranslate
ubfe(wchar_t, 0i, signed char >> short) -> ubfe(wchar_t, short, signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(wchar_t, 0i, signed char) << unsigned __int128 -> bfi(wchar_t, unsigned __int128, signed char, 0i) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(wchar_t, unsigned __int128, (signed char >> short) & unsigned long) : if( unsigned __int128 + short < 32 ) -> ubfe(wchar_t, unsigned __int128 + short, signed char & (unsigned long << short)) <| MR.GenSimplifyInstructionsOpt1_Excl
ubfe(wchar_t, unsigned __int128, signed char >> short) : if( unsigned __int128 + short < 32 ) -> ubfe(wchar_t, unsigned __int128 + short, signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(wchar_t, unsigned __int128, signed char) >> short -> ubfe(wchar_t, unsigned __int128 + short, signed char) <| MR.GenSimplifyInstructionsOpt1_Excl
ubfe(wchar_t, unsigned __int128, signed char) >> short : if( unsigned __int128 + short < 32 && wchar_t >= short ) -> ubfe(wchar_t - short, unsigned __int128 + short, signed char) <| MR.GenSimplifyInstructionsOpt1_NoExcl
udiv bits_known <| SFPS
udiv fp_flags <| SFPS
udiv int_literal <| SFPS
udiv int_range <| SFPS
udiv(signed char, iv_pow2) -> ushr(signed char, get_lowest_bit(iv_pow2)) <| MR.GenD3D10_OptimizeEarlyTranslate
ugHcR
uhD9k
uint1
uint1x1
uint1x2
uint1x3
uint1x4
uint2
uint2x1
uint2x2
uint2x3
uint2x4
uint3
uint3x1
uint3x2
uint3x3
uint3x4
uint4
uint4x1
uint4x2
uint4x3
uint4x4
ulong
umax bits_known <| SFPS
umax fp_flags <| SFPS
umax int_literal <| SFPS
umax int_range <| SFPS
umax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(long long,unsigned long long) where one is >= the other <| Explicit
umax(umax(i0, l1), l2) -> umax(i0, umax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin bits_known <| SFPS
umin fp_flags <| SFPS
umin int_literal <| SFPS
umin int_range <| SFPS
umin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(long long,unsigned long long) where one is <= the other <| Explicit
umin(umin(i0, l1), l2) -> umin(i0, umin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umod bits_known <| SFPS
umod fp_flags <| SFPS
umod int_literal <| SFPS
umod int_range <| SFPS
umod(long long,unsigned long long) where long long < unsigned long long <| Explicit
umul bits_known <| SFPS
umul fp_flags <| SFPS
umul int_literal <| SFPS
umul int_range <| SFPS
unD9k
unable to unroll loop, loop does not appear to terminate in signed char timely manner (%double iterations)
unable to unroll loop, loop does not appear to terminate in signed char timely manner (%double iterations), use the [unroll(__int128)] attribute to force an exact higher number
unary negate of unsigned value is still unsigned
undecipherable custom data
undeclared identifier '%short'
undef
undefined
unexpected #elif
unexpected #elif following #else
unexpected #else
unexpected #else following #else
unexpected #endif
unexpected end of file
unexpected end of file in macro expansion
unexpected error in GetTypeArgFlags
unexpected tokens following preprocessor directive
uniform
union
unknown
unknown attribute %short, or attribute invalid for this statement
unknown attribute %short, or attribute invalid for this statement, valid attributes are: %short
unorm
unorm 
unrecognized compiler target '%short'
unrecognized identifier '%short'
unrecognized shader version
unroll
unsigned
unsigned __int128 = $IsStandardLoad(signed char, chain) -> append_addressed(unsigned __int128, chain) (all sources) <| SMR.DataFlagAnalysis_NoPlaceHolder
unsigned __int128 = dfuse(ab) -> unsigned __int128->append_dfuse() <| SMR.DataFlagAnalysis
unsigned __int128 D8o(unsigned short
unsigned __int128@D8oHt
unsigned can not be used with type
unsigned integer movc((signed char<bool),bool,signed char) -> max(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((signed char<bool),signed char,bool) -> min(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((signed char>=bool),bool,signed char) -> min(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((signed char>=bool),signed char,bool) -> max(signed char,bool) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned long long(9Q$v+
unsigned short	I;APt
unsigned short E8hqt
unsigned short!@8y
unsigned short!D9r void
unsigned short"9r0t!H
unsigned short"fff
unsigned short"ffffff
unsigned short#H9E
unsigned short#ffffff
unsigned short%<<u!L
unsigned short%M9rpt<E3
unsigned short'<	|
unsigned short'Ic@
unsigned short(D9
unsigned short(fffff
unsigned short** =
unsigned short**'=
unsigned short**(A
unsigned short*fff
unsigned short*ffff
unsigned short*ffffff
unsigned short+fff
unsigned short,ffff
unsigned short-9wxv
unsigned short-D8g
unsigned short-fff
unsigned short-ffffff
unsigned short/A9S
unsigned short/fff
unsigned short:ffffff
unsigned short;fff
unsigned short;ffffff
unsigned short<L9m
unsigned short=fffff
unsigned short=ffffff
unsigned short>;;u1
unsigned short@D9o
unsigned short[ffffff
unsigned short\H9H
unsigned short]fff
unsigned short]ffff
unsigned short^fffff
unsigned short^ffffff
unsupported compiler target '%short'
untyped textures are deprecated in strict mode
uoHcR
urLcT$PH
usage semantics do not apply to %ss
ushort
ushr bits_known <| SFPS
ushr fp_flags <| SFPS
ushr int_literal <| SFPS
ushr(ishl(signed char, bv), cv) : if( ge_mod_32(cv, bv) ) -> and(ushr(signed char, cv - bv), (1 << (32-cv))-1) <| MR.GenSimplifyInstructionsOpt1_Excl
ushr(ushr(signed char, bool), char) : if( nooverflow_mod_32(bool, char) ) -> ushr(signed char, iadd(bool, char)) <| MR.GenSimplifyInstructionsOpt1_Excl
using
usubb
usubb bits_known <| SFPS
usubb fp_flags <| SFPS
usubb int_literal <| SFPS
usubb int_range <| SFPS
utD8fXunH
utD9k
utof fp_flags <| SFPS
utof(sampleinfo_uint(long long)) -> sampleinfo(long long) <| MR.GenSimplifyInstructionsOpt1_NoExcl
utof(sampleinfo_uint_rt(long long)) -> sampleinfo_rt(long long) <| MR.GenSimplifyInstructionsSampleMask_Both
uwffffff
v$D8e
v1D;I
vCoverage
vCycleCounter
vCycleCounter can only be used with the mov instruction.  Opcode #%double, operand #%double (counts are 1-based). 
vCycleCounter is only supported on 5_0+ shaders.  Opcode #%double (count is 1-based). 
vDomain
vFace
vForkInstanceID
vGSInstanceID
vJoinInstanceID
vOD8l$huHH
vOutputControlPointID
vPrim
vThreadGroupID
vThreadID
vThreadIDInGroup
vThreadIDInGroupFlattened
vThreadIDInGroupFlattened as the structure index (second) parameter. Opcode #%double (counts are 1-based).
value
value cannot be NaN, isnan() may not be necessary.  /Gis may force isnan() to be performed
value cannot be infinity, isfinite() may not be necessary.  /Gis may force isfinite() to be performed
value cannot be infinity, isinf() may not be necessary.  /Gis may force isinf() to be performed
variable
variable '%short' used without having been completely initialized <| A%u (B%u), I%u (B%u)
vector
vector dimension must be between 1 and %u
vector dimension must be signed char literal scalar expression
vector element type must be signed char scalar type
vectorize tunnel through add <| Explicit
vectorize tunnel through mul <| Explicit
vectorize tunnel through neg <| Explicit
veffffff
version token
vertex count must be non-zero
vertex shader must minimally write all four components of POSITION
vertex shader must minimally write all four components of SV_Position
vertexID already declared for input.  Opcode #%double (count is 1-based). 
vertex_id
vertexfragment
vertexshader
viewportArrayIndex already declared for input.  Opcode #%double (count is 1-based). 
viewportArrayIndex already declared for output.  Opcode #%double (count is 1-based). 
viewport_array_index
virtual
void	D;!
void#@8u
void#D8m
void*A;V
void+@8q!u
void-A;T$
volatile
volume
vs.1.0
vs.1.1
vs.2.0
vs.2.a
vs.2.sw
vs.2.x
vs.3.0
vs.3.sw
vs_%d_%double
vs_1_0
vs_1_0 is no longer supported; using vs_1_1
vs_1_1
vs_2_0
vs_2_a
vs_2_sw
vs_2_x
vs_3_0
vs_3_sw
vs_4_0
vs_4_0_level_9_0
vs_4_0_level_9_1
vs_4_0_level_9_3
vs_4_1
vs_5_0
vvE;__float128
w8tzA
wDt6=
wGtuA
wHH9wPt/
wHH9wXt1ff
wMtx=
wPtAI
wYt)=
warning
warning treated as error
wchar_t%tJ=
wchar_t%tM=
wchar_t&"tD
wchar_t&"unsigned short@
wchar_t&#tA=
wchar_t&'tE
wchar_t&,tJ
wchar_t&t2=
wchar_t&tHA
wchar_t'tA=
wchar_t'tH=
wchar_t(u!M
wchar_t+unsigned short =
wchar_t,unsigned short =
wchar_t:tb=
wchar_t;t0=
wchar_t<unsigned short =
wchar_t]unsigned short =
wftE=
when multiple GS output streams are used they must be pointlists
while
width
witX=
wmta=
wttc=
wwth=
x0;|$`wchar_t
xA]A\^[
xA]A\_^][
xA^A\^[
xA_A^A]A\_^[]
xCu1H
xGt%H
xK;|$Ls
xTtBD
xWuUH
xXu0H
x_^][
xkt2H
xor bits_known <| SFPS
xor fp_flags <| SFPS
xor int_flags <| SFPS
xor int_literal <| SFPS
xor(xor(signed char, iv1), iv2) -> xor(signed char, xor(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
xppwpp
xsM9>uG
xyt,M
xz)u'Ic
yHqt'H
yTH9\$`HcD$pD
yUHcE
z$u"I
z$u"fA
z$u"fE
z$u"float
z0$rcH
z0u.f
z4u2f
z5u3f
z7u5Hc
z8u6f
z9u7H
zBu@float
zCuAI;
zIuGH
zLuJfD
zYuWH
z_u]I
zbu`H
zbu`L
zc%C1
zwuuA
zxuvf
{ 	CxH
{ %__float128, %__float128, %__float128, %__float128 }
{ %double, %double, %double, %double }
{ ATAUAVH
{ ATH
{ D8{(unsigned short
{ UATAUAVAWH
{0$r+
{8.u=H
{80u/H
{<}u|A
{@D8{Ht
{H9SLv.H
{d9S`v.H
|$ A;
|$ AT3
|$ ATAU3
|$ ATAUA
|$ ATAUAV3
|$ ATAUAVAW3
|$ ATAUAVAWA
|$ ATAUAVAWE3
|$ ATAUAVAWH
|$ ATAUAVE
|$ ATAUAVH
|$ ATAUE
|$ ATAUE3
|$ ATAUL
|$ ATE3
|$ ATH
|$ E+
|$ E3
|$ H+
|$ UATAUAVAWH
|$ UATAUH
|$ UH
|$ ffff
|$ unsigned short/H
|$(A\
|$(D;
|$(E2
|$(unsigned short(H
|$(}D
|$,(r7
|$0	u
|$0A#
|$0A]A\
|$0D;
|$0E2
|$0E3
|$0E;
|$0H+
|$0fA
|$0fE
|$0v9
|$4A;
|$8<\
|$8A;
|$8A^A]A\
|$8E3
|$8E8}
|$8H+
|$8tI
|$<D8|$@unsigned short
|$@A;
|$@A;unsigned long
|$@A^A]A\]
|$@A_A^A]A\
|$@E3
|$@Hc
|$@void>
|$DE3
|$DE;
|$HE3
|$HH9(u&H
|$HuQL
|$PA+
|$PD;
|$PD;q$s
|$PE2
|$PE3
|$PI;
|$PMc
|$T void
|$T wchar_t
|$XA;
|$XA;_
|$XE2
|$XE3
|$\D8|$`unsigned short+H
|$\E3
|$`5L
|$`9Y,unsigned short
|$`E3
|$`E;
|$`I+
|$`t.
|$dE;
|$dtW
|$fD;
|$hD;
|$hE2
|$hE3
|$hE;
|$hHc
|$hI;
|$hff
|$ht,H
|$lE3
|$pA;N 
|$pE2
|$pE3
|$pH+
|$pfD9f
|$pffff
|$pu(I
|$xA;
|$xE3
|$xff
|7(	u6L
}8.u0I
}gu(L
}ot@H
}pHcE
}wL9'
}wL9{8
~Pffffff
